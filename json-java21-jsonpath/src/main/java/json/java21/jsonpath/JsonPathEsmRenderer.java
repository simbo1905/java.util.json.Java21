package json.java21.jsonpath;

import json.java21.jsonpath.JsonPathAst.*;

import java.util.List;
import java.util.logging.Logger;

/// Renders a JsonPath AST into an ES2020 module that exports a `query(document)` function.
///
/// The generated JavaScript evaluates the JsonPath expression against a JSON document
/// and returns an array of matched values. All dispatch decisions are resolved at
/// render time - no interpretation at runtime.
///
/// Usage:
/// ```java
/// var ast = JsonPath.parse("$.store.book[*].title").ast();
/// String esm = JsonPathEsmRenderer.render(ast, "$.store.book[*].title");
/// // esm contains: export function query(root) { ... }
/// ```
public final class JsonPathEsmRenderer {

    private static final Logger LOG = Logger.getLogger(JsonPathEsmRenderer.class.getName());

    private JsonPathEsmRenderer() {}

    /// Renders a JsonPath AST into an ES2020 module string.
    ///
    /// @param ast the parsed JsonPath AST root
    /// @param expression the original expression string (for comments)
    /// @return a complete ES2020 module string
    public static String render(Root ast, String expression) {
        final var sb = new StringBuilder();

        sb.append("// Generated JsonPath query: ").append(expression).append('\n');
        sb.append("// Do not edit - generated by JsonPathEsmRenderer\n\n");

        sb.append("export function query(root) {\n");
        sb.append("  const results = [];\n");

        emitSegmentChain(sb, ast.segments(), 0, "root", "root", "  ");

        sb.append("  return results;\n");
        sb.append("}\n");

        LOG.fine(() -> "Rendered ESM for: " + expression);
        return sb.toString();
    }

    private static void emitSegmentChain(StringBuilder sb, List<Segment> segments,
            int segIdx, String currentVar, String rootVar, String indent) {

        if (segIdx >= segments.size()) {
            sb.append(indent).append("results.push(").append(currentVar).append(");\n");
            return;
        }

        final var segment = segments.get(segIdx);

        switch (segment) {
            case PropertyAccess prop ->
                emitPropertyAccess(sb, prop, segments, segIdx, currentVar, rootVar, indent);
            case ArrayIndex arr ->
                emitArrayIndex(sb, arr, segments, segIdx, currentVar, rootVar, indent);
            case ArraySlice slice ->
                emitArraySlice(sb, slice, segments, segIdx, currentVar, rootVar, indent);
            case Wildcard ignored ->
                emitWildcard(sb, segments, segIdx, currentVar, rootVar, indent);
            case RecursiveDescent desc ->
                emitRecursiveDescent(sb, desc, segments, segIdx, currentVar, rootVar, indent);
            case Filter filter ->
                emitFilter(sb, filter, segments, segIdx, currentVar, rootVar, indent);
            case Union union ->
                emitUnion(sb, union, segments, segIdx, currentVar, rootVar, indent);
            case ScriptExpression script ->
                emitScript(sb, script, segments, segIdx, currentVar, rootVar, indent);
        }
    }

    private static void emitPropertyAccess(StringBuilder sb, PropertyAccess prop,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        final var jsName = jsString(prop.name());
        sb.append(indent).append("if (").append(currentVar).append(" != null && typeof ")
          .append(currentVar).append(" === 'object' && !Array.isArray(").append(currentVar).append(")) {\n");
        final var valVar = "v" + segIdx;
        sb.append(indent).append("  const ").append(valVar).append(" = ").append(currentVar)
          .append("[").append(jsName).append("];\n");
        sb.append(indent).append("  if (").append(valVar).append(" !== undefined) {\n");

        emitSegmentChain(sb, segments, segIdx + 1, valVar, rootVar, indent + "    ");

        sb.append(indent).append("  }\n");
        sb.append(indent).append("}\n");
    }

    private static void emitArrayIndex(StringBuilder sb, ArrayIndex arr,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        sb.append(indent).append("if (Array.isArray(").append(currentVar).append(")) {\n");
        final var idxExpr = arr.index() < 0
            ? currentVar + ".length + " + arr.index()
            : String.valueOf(arr.index());
        final var iVar = "i" + segIdx;
        sb.append(indent).append("  const ").append(iVar).append(" = ").append(idxExpr).append(";\n");
        sb.append(indent).append("  if (").append(iVar).append(" >= 0 && ").append(iVar)
          .append(" < ").append(currentVar).append(".length) {\n");
        final var elemVar = "e" + segIdx;
        sb.append(indent).append("    const ").append(elemVar).append(" = ").append(currentVar)
          .append("[").append(iVar).append("];\n");

        emitSegmentChain(sb, segments, segIdx + 1, elemVar, rootVar, indent + "    ");

        sb.append(indent).append("  }\n");
        sb.append(indent).append("}\n");
    }

    private static void emitArraySlice(StringBuilder sb, ArraySlice slice,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        sb.append(indent).append("if (Array.isArray(").append(currentVar).append(")) {\n");

        final var step = slice.step() != null ? slice.step() : 1;
        final var iVar = "i" + segIdx;
        final var lenVar = "len" + segIdx;
        sb.append(indent).append("  const ").append(lenVar).append(" = ").append(currentVar).append(".length;\n");

        if (step > 0) {
            final var startExpr = slice.start() != null
                ? "Math.max(0, " + normalizeIdx(slice.start(), lenVar) + ")"
                : "0";
            final var endExpr = slice.end() != null
                ? "Math.min(" + lenVar + ", " + normalizeIdx(slice.end(), lenVar) + ")"
                : lenVar;
            sb.append(indent).append("  for (let ").append(iVar).append(" = ").append(startExpr)
              .append("; ").append(iVar).append(" < ").append(endExpr)
              .append("; ").append(iVar).append(" += ").append(step).append(") {\n");
        } else {
            final var startExpr = slice.start() != null
                ? "Math.min(" + lenVar + " - 1, " + normalizeIdx(slice.start(), lenVar) + ")"
                : lenVar + " - 1";
            final var endExpr = slice.end() != null
                ? normalizeIdx(slice.end(), lenVar)
                : "-1";
            sb.append(indent).append("  for (let ").append(iVar).append(" = ").append(startExpr)
              .append("; ").append(iVar).append(" > ").append(endExpr)
              .append(" && ").append(iVar).append(" >= 0 && ").append(iVar).append(" < ").append(lenVar)
              .append("; ").append(iVar).append(" += ").append(step).append(") {\n");
        }

        final var elemVar = "e" + segIdx;
        sb.append(indent).append("    const ").append(elemVar).append(" = ")
          .append(currentVar).append("[").append(iVar).append("];\n");

        emitSegmentChain(sb, segments, segIdx + 1, elemVar, rootVar, indent + "    ");

        sb.append(indent).append("  }\n");
        sb.append(indent).append("}\n");
    }

    private static String normalizeIdx(int idx, String lenVar) {
        return idx < 0 ? lenVar + " + " + idx : String.valueOf(idx);
    }

    private static void emitWildcard(StringBuilder sb,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        final var valVar = "w" + segIdx;

        sb.append(indent).append("if (Array.isArray(").append(currentVar).append(")) {\n");
        sb.append(indent).append("  for (const ").append(valVar).append(" of ").append(currentVar).append(") {\n");
        emitSegmentChain(sb, segments, segIdx + 1, valVar, rootVar, indent + "    ");
        sb.append(indent).append("  }\n");

        sb.append(indent).append("} else if (").append(currentVar).append(" != null && typeof ")
          .append(currentVar).append(" === 'object') {\n");
        sb.append(indent).append("  for (const ").append(valVar).append(" of Object.values(")
          .append(currentVar).append(")) {\n");
        emitSegmentChain(sb, segments, segIdx + 1, valVar, rootVar, indent + "    ");
        sb.append(indent).append("  }\n");

        sb.append(indent).append("}\n");
    }

    private static void emitRecursiveDescent(StringBuilder sb, RecursiveDescent desc,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        final var target = desc.target();
        final var fnName = "_descent" + segIdx;
        final var nodeVar = "n" + segIdx;

        // Emit a local recursive function
        sb.append(indent).append("function ").append(fnName).append("(").append(nodeVar).append(") {\n");

        // Match target at current level
        switch (target) {
            case PropertyAccess prop -> {
                sb.append(indent).append("  if (").append(nodeVar).append(" != null && typeof ")
                  .append(nodeVar).append(" === 'object' && !Array.isArray(").append(nodeVar).append(")) {\n");
                sb.append(indent).append("    const _m = ").append(nodeVar).append("[")
                  .append(jsString(prop.name())).append("];\n");
                sb.append(indent).append("    if (_m !== undefined) {\n");
                emitSegmentChain(sb, segments, segIdx + 1, "_m", rootVar, indent + "      ");
                sb.append(indent).append("    }\n");
                sb.append(indent).append("  }\n");
            }
            case Wildcard ignored2 -> {
                sb.append(indent).append("  if (Array.isArray(").append(nodeVar).append(")) {\n");
                sb.append(indent).append("    for (const _m of ").append(nodeVar).append(") {\n");
                emitSegmentChain(sb, segments, segIdx + 1, "_m", rootVar, indent + "      ");
                sb.append(indent).append("    }\n");
                sb.append(indent).append("  } else if (").append(nodeVar).append(" != null && typeof ")
                  .append(nodeVar).append(" === 'object') {\n");
                sb.append(indent).append("    for (const _m of Object.values(").append(nodeVar).append(")) {\n");
                emitSegmentChain(sb, segments, segIdx + 1, "_m", rootVar, indent + "      ");
                sb.append(indent).append("    }\n");
                sb.append(indent).append("  }\n");
            }
            default -> {
                // Unsupported target in recursive descent
            }
        }

        // Recurse into children
        sb.append(indent).append("  if (Array.isArray(").append(nodeVar).append(")) {\n");
        sb.append(indent).append("    for (const _c of ").append(nodeVar).append(") ").append(fnName).append("(_c);\n");
        sb.append(indent).append("  } else if (").append(nodeVar).append(" != null && typeof ")
          .append(nodeVar).append(" === 'object') {\n");
        sb.append(indent).append("    for (const _c of Object.values(").append(nodeVar).append(")) ").append(fnName).append("(_c);\n");
        sb.append(indent).append("  }\n");

        sb.append(indent).append("}\n");
        sb.append(indent).append(fnName).append("(").append(currentVar).append(");\n");
    }

    private static void emitFilter(StringBuilder sb, Filter filter,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        sb.append(indent).append("if (Array.isArray(").append(currentVar).append(")) {\n");
        final var elemVar = "f" + segIdx;
        sb.append(indent).append("  for (const ").append(elemVar).append(" of ").append(currentVar).append(") {\n");
        sb.append(indent).append("    if (");
        emitFilterExpression(sb, filter.expression(), elemVar);
        sb.append(") {\n");

        emitSegmentChain(sb, segments, segIdx + 1, elemVar, rootVar, indent + "      ");

        sb.append(indent).append("    }\n");
        sb.append(indent).append("  }\n");
        sb.append(indent).append("}\n");
    }

    private static void emitFilterExpression(StringBuilder sb, FilterExpression expr, String elemVar) {
        switch (expr) {
            case ExistsFilter exists -> {
                emitPropertyPathAccess(sb, exists.path(), elemVar);
                sb.append(" !== undefined");
            }
            case ComparisonFilter comp -> {
                sb.append("(");
                emitFilterOperand(sb, comp.left(), elemVar);
                sb.append(" ").append(jsOp(comp.op())).append(" ");
                emitFilterOperand(sb, comp.right(), elemVar);
                sb.append(")");
            }
            case LogicalFilter logical -> {
                switch (logical.op()) {
                    case AND -> {
                        sb.append("(");
                        emitFilterExpression(sb, logical.left(), elemVar);
                        sb.append(" && ");
                        if (logical.right() != null) {
                            emitFilterExpression(sb, logical.right(), elemVar);
                        } else {
                            sb.append("true");
                        }
                        sb.append(")");
                    }
                    case OR -> {
                        sb.append("(");
                        emitFilterExpression(sb, logical.left(), elemVar);
                        sb.append(" || ");
                        if (logical.right() != null) {
                            emitFilterExpression(sb, logical.right(), elemVar);
                        } else {
                            sb.append("false");
                        }
                        sb.append(")");
                    }
                    case NOT -> {
                        sb.append("!(");
                        emitFilterExpression(sb, logical.left(), elemVar);
                        sb.append(")");
                    }
                }
            }
            case CurrentNode cn -> sb.append("true");
            case PropertyPath path -> {
                emitPropertyPathAccess(sb, path, elemVar);
                sb.append(" !== undefined");
            }
            case LiteralValue lv -> sb.append("true");
        }
    }

    private static void emitFilterOperand(StringBuilder sb, FilterExpression expr, String elemVar) {
        switch (expr) {
            case PropertyPath path -> emitPropertyPathAccess(sb, path, elemVar);
            case LiteralValue lit -> {
                if (lit.value() == null) {
                    sb.append("null");
                } else if (lit.value() instanceof String s) {
                    sb.append(jsString(s));
                } else if (lit.value() instanceof Number n) {
                    sb.append(n);
                } else if (lit.value() instanceof Boolean b) {
                    sb.append(b);
                } else {
                    sb.append("null");
                }
            }
            case CurrentNode cn2 -> sb.append(elemVar);
            default -> sb.append("null");
        }
    }

    private static void emitPropertyPathAccess(StringBuilder sb, PropertyPath path, String elemVar) {
        sb.append(elemVar);
        for (final var prop : path.properties()) {
            sb.append("?.[").append(jsString(prop)).append("]");
        }
    }

    private static void emitUnion(StringBuilder sb, Union union,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        for (final var selector : union.selectors()) {
            switch (selector) {
                case PropertyAccess prop ->
                    emitPropertyAccess(sb, prop, segments, segIdx, currentVar, rootVar, indent);
                case ArrayIndex arr ->
                    emitArrayIndex(sb, arr, segments, segIdx, currentVar, rootVar, indent);
                default -> {}
            }
        }
    }

    private static void emitScript(StringBuilder sb, ScriptExpression script,
            List<Segment> segments, int segIdx, String currentVar, String rootVar, String indent) {
        if ("@.length-1".equals(script.script())) {
            sb.append(indent).append("if (Array.isArray(").append(currentVar)
              .append(") && ").append(currentVar).append(".length > 0) {\n");
            final var elemVar = "s" + segIdx;
            sb.append(indent).append("  const ").append(elemVar).append(" = ")
              .append(currentVar).append("[").append(currentVar).append(".length - 1];\n");

            emitSegmentChain(sb, segments, segIdx + 1, elemVar, rootVar, indent + "  ");

            sb.append(indent).append("}\n");
        }
    }

    private static String jsString(String s) {
        return "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
    }

    private static String jsOp(ComparisonOp op) {
        return switch (op) {
            case EQ -> "===";
            case NE -> "!==";
            case LT -> "<";
            case LE -> "<=";
            case GT -> ">";
            case GE -> ">=";
        };
    }
}
