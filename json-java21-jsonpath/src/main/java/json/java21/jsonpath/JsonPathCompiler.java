package json.java21.jsonpath;

import javax.tools.*;
import java.io.*;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.logging.Logger;

/// Compiles JsonPath AST into optimized bytecode using JDK compiler tools.
/// Uses the Java Compiler API (javax.tools) to generate and compile Java source at runtime.
final class JsonPathCompiler {

    private static final Logger LOG = Logger.getLogger(JsonPathCompiler.class.getName());

    /// Counter for generating unique class names
    private static long classCounter = 0;

    private JsonPathCompiler() {
        // utility class
    }

    /// Compiles an interpreted JsonPath into an optimized compiled version.
    /// @param interpreted the AST-based JsonPath to compile
    /// @return a compiled JsonPath with generated bytecode
    static JsonPathCompiled compile(JsonPathInterpreted interpreted) {
        Objects.requireNonNull(interpreted, "interpreted must not be null");
        LOG.fine(() -> "Compiling JsonPath: " + interpreted);

        final var ast = interpreted.ast();
        final var originalPath = interpreted.toString();

        // Generate a unique class name
        final var className = generateClassName();
        LOG.finer(() -> "Generated class name: " + className);

        // Generate the Java source code
        final var sourceCode = generateSourceCode(className, ast);
        LOG.finer(() -> "Generated source code:\n" + sourceCode);

        // Compile the source code
        final var executor = compileAndInstantiate(className, sourceCode);

        return new JsonPathCompiled(ast, executor, originalPath);
    }

    /// Generates a unique class name for the compiled JsonPath executor.
    private static synchronized String generateClassName() {
        return "JsonPathExecutor_" + (classCounter++);
    }

    /// Generates Java source code that implements the JsonPath query.
    static String generateSourceCode(String className, JsonPathAst.Root ast) {
        final var sb = new StringBuilder();

        // Package and imports
        sb.append("""
                package json.java21.jsonpath.generated;

                import jdk.sandbox.java.util.json.*;
                import json.java21.jsonpath.JsonPathExecutor;
                import json.java21.jsonpath.JsonPathHelpers;
                import java.util.*;

                public final class %s implements JsonPathExecutor {

                    @Override
                    public List<JsonValue> execute(JsonValue current, JsonValue root) {
                        final var results = new ArrayList<JsonValue>();
                """.formatted(className));

        // Generate the evaluation code
        generateSegmentEvaluation(sb, ast.segments(), 0, "current", "root", "results");

        // Close the execute method and class
        sb.append("""
                        return results;
                    }
                }
                """);

        return sb.toString();
    }

    /// Generates evaluation code for a sequence of segments.
    private static void generateSegmentEvaluation(
            StringBuilder sb,
            List<JsonPathAst.Segment> segments,
            int segmentIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        // If we've processed all segments, add current to results
        if (segmentIndex >= segments.size()) {
            sb.append("        %s.add(%s);\n".formatted(resultsVar, currentVar));
            return;
        }

        final var segment = segments.get(segmentIndex);
        final var nextIndex = segmentIndex + 1;

        switch (segment) {
            case JsonPathAst.PropertyAccess prop ->
                    generatePropertyAccess(sb, prop, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ArrayIndex arr ->
                    generateArrayIndex(sb, arr, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ArraySlice slice ->
                    generateArraySlice(sb, slice, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Wildcard ignored ->
                    generateWildcard(sb, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.RecursiveDescent desc ->
                    generateRecursiveDescent(sb, desc, segments, segmentIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Filter filter ->
                    generateFilter(sb, filter, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Union union ->
                    generateUnion(sb, union, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ScriptExpression script ->
                    generateScriptExpression(sb, script, segments, nextIndex, currentVar, rootVar, resultsVar);
        }
    }

    private static void generatePropertyAccess(
            StringBuilder sb,
            JsonPathAst.PropertyAccess prop,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var tempVar = "v" + nextIndex;
        sb.append("        if (%s instanceof JsonObject obj%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var %s = obj%d.members().get(\"%s\");\n"
                .formatted(tempVar, nextIndex, escapeJavaString(prop.name())));
        sb.append("            if (%s != null) {\n".formatted(tempVar));
        generateSegmentEvaluation(sb, segments, nextIndex, tempVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateArrayIndex(
            StringBuilder sb,
            JsonPathAst.ArrayIndex arr,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var tempVar = "e" + nextIndex;
        final var idxVar = "idx" + nextIndex;
        sb.append("        if (%s instanceof JsonArray arr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var elements%d = arr%d.elements();\n".formatted(nextIndex, nextIndex));
        sb.append("            int %s = %d;\n".formatted(idxVar, arr.index()));
        sb.append("            if (%s < 0) %s = elements%d.size() + %s;\n".formatted(idxVar, idxVar, nextIndex, idxVar));
        sb.append("            if (%s >= 0 && %s < elements%d.size()) {\n".formatted(idxVar, idxVar, nextIndex));
        sb.append("                final var %s = elements%d.get(%s);\n".formatted(tempVar, nextIndex, idxVar));
        generateSegmentEvaluation(sb, segments, nextIndex, tempVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateArraySlice(
            StringBuilder sb,
            JsonPathAst.ArraySlice slice,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        sb.append("        if (%s instanceof JsonArray arr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var elements%d = arr%d.elements();\n".formatted(nextIndex, nextIndex));
        sb.append("            final int size%d = elements%d.size();\n".formatted(nextIndex, nextIndex));

        final int step = slice.step() != null ? slice.step() : 1;
        sb.append("            final int step%d = %d;\n".formatted(nextIndex, step));

        if (step > 0) {
            final var startExpr = slice.start() != null ?
                    "JsonPathHelpers.normalizeIdx(%d, size%d)".formatted(slice.start(), nextIndex) : "0";
            final var endExpr = slice.end() != null ?
                    "JsonPathHelpers.normalizeIdx(%d, size%d)".formatted(slice.end(), nextIndex) : "size" + nextIndex;

            sb.append("            int start%d = %s;\n".formatted(nextIndex, startExpr));
            sb.append("            int end%d = %s;\n".formatted(nextIndex, endExpr));
            sb.append("            start%d = Math.max(0, Math.min(start%d, size%d));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            end%d = Math.max(0, Math.min(end%d, size%d));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            for (int i%d = start%d; i%d < end%d; i%d += step%d) {\n"
                    .formatted(nextIndex, nextIndex, nextIndex, nextIndex, nextIndex, nextIndex));
        } else {
            final var startExpr = slice.start() != null ?
                    "JsonPathHelpers.normalizeIdx(%d, size%d)".formatted(slice.start(), nextIndex) : "size%d - 1".formatted(nextIndex);
            final var endExpr = slice.end() != null ?
                    "JsonPathHelpers.normalizeIdx(%d, size%d)".formatted(slice.end(), nextIndex) : "-1";

            sb.append("            int start%d = %s;\n".formatted(nextIndex, startExpr));
            sb.append("            int end%d = %s;\n".formatted(nextIndex, endExpr));
            sb.append("            start%d = Math.max(0, Math.min(start%d, size%d - 1));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            for (int i%d = start%d; i%d > end%d; i%d += step%d) {\n"
                    .formatted(nextIndex, nextIndex, nextIndex, nextIndex, nextIndex, nextIndex));
        }

        final var elemVar = "elem" + nextIndex;
        sb.append("                final var %s = elements%d.get(i%d);\n".formatted(elemVar, nextIndex, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateWildcard(
            StringBuilder sb,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var elemVar = "wc" + nextIndex;
        sb.append("        if (%s instanceof JsonObject wobj%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : wobj%d.members().values()) {\n".formatted(elemVar, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        } else if (%s instanceof JsonArray warr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : warr%d.elements()) {\n".formatted(elemVar, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateRecursiveDescent(
            StringBuilder sb,
            JsonPathAst.RecursiveDescent desc,
            List<JsonPathAst.Segment> segments,
            int segmentIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final int nextIndex = segmentIndex + 1;

        // For simple cases (property access or wildcard with no following segments), generate inline
        if (nextIndex >= segments.size()) {
            // Terminal recursive descent - generate simple code
            switch (desc.target()) {
                case JsonPathAst.PropertyAccess prop -> {
                    sb.append("        // Recursive descent for property: %s\n".formatted(prop.name()));
                    sb.append("        JsonPathHelpers.evaluateRecursiveDescent(\"%s\", %s, %s);\n"
                            .formatted(escapeJavaString(prop.name()), currentVar, resultsVar));
                }
                case JsonPathAst.Wildcard ignored -> {
                    sb.append("        // Recursive descent wildcard\n");
                    sb.append("        JsonPathHelpers.evaluateRecursiveDescent(null, %s, %s);\n"
                            .formatted(currentVar, resultsVar));
                }
                default -> {
                    // Complex target - generate a recursive helper inline
                    sb.append("        // Recursive descent with complex target - inline generation\n");
                    generateRecursiveDescentInline(sb, desc, segments, segmentIndex, currentVar, rootVar, resultsVar);
                }
            }
        } else {
            // Has following segments - need to generate more complex code
            generateRecursiveDescentInline(sb, desc, segments, segmentIndex, currentVar, rootVar, resultsVar);
        }
    }

    private static void generateRecursiveDescentInline(
            StringBuilder sb,
            JsonPathAst.RecursiveDescent desc,
            List<JsonPathAst.Segment> segments,
            int segmentIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final int nextIndex = segmentIndex + 1;
        final var collectVar = "rdCollect" + nextIndex;
        final var iterVar = "rdItem" + nextIndex;

        // For complex recursive descent, we collect intermediate results first
        // then process them with subsequent segments
        switch (desc.target()) {
            case JsonPathAst.PropertyAccess prop -> {
                sb.append("        // Recursive descent for property with following segments: %s\n".formatted(prop.name()));
                sb.append("        final var %s = new ArrayList<JsonValue>();\n".formatted(collectVar));
                sb.append("        JsonPathHelpers.evaluateRecursiveDescent(\"%s\", %s, %s);\n"
                        .formatted(escapeJavaString(prop.name()), currentVar, collectVar));
                sb.append("        for (final var %s : %s) {\n".formatted(iterVar, collectVar));
                generateSegmentEvaluation(sb, segments, nextIndex, iterVar, rootVar, resultsVar);
                sb.append("        }\n");
            }
            case JsonPathAst.Wildcard ignored -> {
                sb.append("        // Recursive descent wildcard with following segments\n");
                sb.append("        final var %s = new ArrayList<JsonValue>();\n".formatted(collectVar));
                sb.append("        JsonPathHelpers.evaluateRecursiveDescent(null, %s, %s);\n"
                        .formatted(currentVar, collectVar));
                sb.append("        for (final var %s : %s) {\n".formatted(iterVar, collectVar));
                generateSegmentEvaluation(sb, segments, nextIndex, iterVar, rootVar, resultsVar);
                sb.append("        }\n");
            }
            case JsonPathAst.ArrayIndex arr -> {
                // Recursive descent with array index target (e.g., $..book[2])
                sb.append("        // Recursive descent for array index: [%d]\n".formatted(arr.index()));
                sb.append("        final var %s = new ArrayList<JsonValue>();\n".formatted(collectVar));
                // First collect all arrays
                sb.append("        JsonPathHelpers.collectArrays(%s, %s);\n".formatted(currentVar, collectVar));
                sb.append("        for (final var arrItem%d : %s) {\n".formatted(nextIndex, collectVar));
                generateArrayIndex(sb, arr, segments, nextIndex, "arrItem" + nextIndex, rootVar, resultsVar);
                sb.append("        }\n");
            }
            default -> {
                // Unsupported target - add results of current
                sb.append("        // Unsupported recursive descent target - adding current\n");
                sb.append("        %s.add(%s);\n".formatted(resultsVar, currentVar));
            }
        }
    }


    private static void generateFilter(
            StringBuilder sb,
            JsonPathAst.Filter filter,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var elemVar = "fe" + nextIndex;
        sb.append("        if (%s instanceof JsonArray farr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : farr%d.elements()) {\n".formatted(elemVar, nextIndex));
        sb.append("                if (");
        generateFilterCondition(sb, filter.expression(), elemVar);
        sb.append(") {\n");
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("                }\n");
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateFilterCondition(StringBuilder sb, JsonPathAst.FilterExpression expr, String currentVar) {
        switch (expr) {
            case JsonPathAst.ExistsFilter exists -> {
                generatePropertyPathAccess(sb, exists.path(), currentVar);
                sb.append(" != null");
            }
            case JsonPathAst.ComparisonFilter comp -> {
                sb.append("JsonPathHelpers.compareValues(");
                generateFilterValue(sb, comp.left(), currentVar);
                sb.append(", \"").append(comp.op().name()).append("\", ");
                generateFilterValue(sb, comp.right(), currentVar);
                sb.append(")");
            }
            case JsonPathAst.LogicalFilter logical -> {
                switch (logical.op()) {
                    case AND -> {
                        sb.append("(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(" && ");
                        generateFilterCondition(sb, logical.right(), currentVar);
                        sb.append(")");
                    }
                    case OR -> {
                        sb.append("(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(" || ");
                        generateFilterCondition(sb, logical.right(), currentVar);
                        sb.append(")");
                    }
                    case NOT -> {
                        sb.append("!(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(")");
                    }
                }
            }
            case JsonPathAst.CurrentNode ignored -> sb.append("true");
            case JsonPathAst.PropertyPath path -> {
                generatePropertyPathAccess(sb, path, currentVar);
                sb.append(" != null");
            }
            case JsonPathAst.LiteralValue ignored -> sb.append("true");
        }
    }

    private static void generatePropertyPathAccess(StringBuilder sb, JsonPathAst.PropertyPath path, String currentVar) {
        sb.append("JsonPathHelpers.getPath(%s".formatted(currentVar));
        for (final var prop : path.properties()) {
            sb.append(", \"").append(escapeJavaString(prop)).append("\"");
        }
        sb.append(")");
    }

    private static void generateFilterValue(StringBuilder sb, JsonPathAst.FilterExpression expr, String currentVar) {
        switch (expr) {
            case JsonPathAst.PropertyPath path -> {
                sb.append("JsonPathHelpers.toComparable(");
                generatePropertyPathAccess(sb, path, currentVar);
                sb.append(")");
            }
            case JsonPathAst.LiteralValue lit -> {
                if (lit.value() == null) {
                    sb.append("null");
                } else if (lit.value() instanceof String s) {
                    sb.append("\"").append(escapeJavaString(s)).append("\"");
                } else if (lit.value() instanceof Number n) {
                    sb.append(n.doubleValue());
                } else if (lit.value() instanceof Boolean b) {
                    sb.append(b);
                } else {
                    sb.append("null");
                }
            }
            case JsonPathAst.CurrentNode ignored ->
                    sb.append("JsonPathHelpers.toComparable(%s)".formatted(currentVar));
            default -> sb.append("null");
        }
    }

    private static void generateUnion(
            StringBuilder sb,
            JsonPathAst.Union union,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        for (final var selector : union.selectors()) {
            switch (selector) {
                case JsonPathAst.ArrayIndex arr ->
                        generateArrayIndex(sb, arr, segments, nextIndex, currentVar, rootVar, resultsVar);
                case JsonPathAst.PropertyAccess prop ->
                        generatePropertyAccess(sb, prop, segments, nextIndex, currentVar, rootVar, resultsVar);
                default -> {
                    // Unsupported selector, skip
                }
            }
        }
    }

    private static void generateScriptExpression(
            StringBuilder sb,
            JsonPathAst.ScriptExpression script,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        // Only support @.length-1 pattern for now
        if (script.script().trim().equals("@.length-1")) {
            sb.append("        if (%s instanceof JsonArray sarr%d) {\n".formatted(currentVar, nextIndex));
            sb.append("            final int lastIdx%d = sarr%d.elements().size() - 1;\n".formatted(nextIndex, nextIndex));
            sb.append("            if (lastIdx%d >= 0) {\n".formatted(nextIndex));
            final var elemVar = "se" + nextIndex;
            sb.append("                final var %s = sarr%d.elements().get(lastIdx%d);\n".formatted(elemVar, nextIndex, nextIndex));
            generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
            sb.append("            }\n");
            sb.append("        }\n");
        } else {
            // Unsupported script - log warning and skip
            // Only @.length-1 is supported in compiled mode
            sb.append("        // WARNING: Unsupported script expression '%s' - skipped in compiled mode\n"
                    .formatted(escapeJavaString(script.script())));
            sb.append("        // Consider using slice notation instead: [-1:] for last element\n");
        }
    }

    /// Compiles the generated source code and instantiates the executor.
    private static JsonPathExecutor compileAndInstantiate(String className, String sourceCode) {
        final var compiler = ToolProvider.getSystemJavaCompiler();
        if (compiler == null) {
            LOG.warning(() -> "No Java compiler available - falling back to interpreter delegation");
            throw new RuntimeException("Java compiler not available. Ensure you're running with a JDK, not a JRE.");
        }

        final var fileManager = new InMemoryFileManager(compiler.getStandardFileManager(null, null, StandardCharsets.UTF_8));

        // Create a source file object
        final var fullClassName = "json.java21.jsonpath.generated." + className;
        final var sourceFile = new InMemoryJavaFileObject(fullClassName, sourceCode);

        // Compile the source
        final var diagnostics = new DiagnosticCollector<JavaFileObject>();
        final var compilationUnits = Collections.singletonList(sourceFile);
        final var options = List.of(
                "-classpath", System.getProperty("java.class.path"),
                "--add-exports", "json.java21.jsonpath/json.java21.jsonpath=ALL-UNNAMED",
                "--add-exports", "json.java21/jdk.sandbox.java.util.json=ALL-UNNAMED"
        );

        final var task = compiler.getTask(null, fileManager, diagnostics, options, null, compilationUnits);
        final boolean success = task.call();

        if (!success) {
            final var errors = new StringBuilder("Compilation failed:\n");
            for (final var diagnostic : diagnostics.getDiagnostics()) {
                errors.append(diagnostic.toString()).append("\n");
            }
            errors.append("\nSource code:\n").append(sourceCode);
            LOG.severe(() -> "ERROR: " + errors);
            throw new RuntimeException(errors.toString());
        }

        // Load and instantiate the compiled class
        try {
            final var classLoader = new InMemoryClassLoader(fileManager.getClassBytes());
            final var clazz = classLoader.loadClass(fullClassName);
            return (JsonPathExecutor) clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate compiled JsonPath executor", e);
        }
    }

    private static String escapeJavaString(String s) {
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    /// In-memory Java source file object for compilation.
    private static final class InMemoryJavaFileObject extends SimpleJavaFileObject {
        private final String code;

        InMemoryJavaFileObject(String className, String code) {
            super(URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
            this.code = code;
        }

        @Override
        public CharSequence getCharContent(boolean ignoreEncodingErrors) {
            return code;
        }
    }

    /// In-memory class file object for capturing compiled bytecode.
    private static final class InMemoryClassFileObject extends SimpleJavaFileObject {
        private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        InMemoryClassFileObject(String className) {
            super(URI.create("mem:///" + className.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
        }

        @Override
        public OutputStream openOutputStream() {
            return outputStream;
        }

        byte[] getBytes() {
            return outputStream.toByteArray();
        }
    }

    /// In-memory file manager that captures compiled class files.
    private static final class InMemoryFileManager extends ForwardingJavaFileManager<StandardJavaFileManager> {
        private final Map<String, InMemoryClassFileObject> classFiles = new HashMap<>();

        InMemoryFileManager(StandardJavaFileManager fileManager) {
            super(fileManager);
        }

        @Override
        public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) {
            if (kind == JavaFileObject.Kind.CLASS) {
                final var classFile = new InMemoryClassFileObject(className);
                classFiles.put(className, classFile);
                return classFile;
            }
            return null;
        }

        Map<String, byte[]> getClassBytes() {
            final var result = new HashMap<String, byte[]>();
            for (final var entry : classFiles.entrySet()) {
                result.put(entry.getKey(), entry.getValue().getBytes());
            }
            return result;
        }
    }

    /// Class loader that loads compiled classes from memory.
    private static final class InMemoryClassLoader extends ClassLoader {
        private final Map<String, byte[]> classBytes;

        InMemoryClassLoader(Map<String, byte[]> classBytes) {
            super(JsonPathCompiler.class.getClassLoader());
            this.classBytes = classBytes;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            final var bytes = classBytes.get(name);
            if (bytes != null) {
                return defineClass(name, bytes, 0, bytes.length);
            }
            return super.findClass(name);
        }
    }
}
