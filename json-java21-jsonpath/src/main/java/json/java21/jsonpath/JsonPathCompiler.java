package json.java21.jsonpath;

import javax.tools.*;
import java.io.*;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.logging.Logger;

/// Compiles JsonPath AST into optimized bytecode using JDK compiler tools.
/// Uses the Java Compiler API (javax.tools) to generate and compile Java source at runtime.
final class JsonPathCompiler {

    private static final Logger LOG = Logger.getLogger(JsonPathCompiler.class.getName());

    /// Counter for generating unique class names
    private static long classCounter = 0;

    private JsonPathCompiler() {
        // utility class
    }

    /// Compiles an interpreted JsonPath into an optimized compiled version.
    /// @param interpreted the AST-based JsonPath to compile
    /// @return a compiled JsonPath with generated bytecode
    static JsonPathCompiled compile(JsonPathInterpreted interpreted) {
        Objects.requireNonNull(interpreted, "interpreted must not be null");
        LOG.fine(() -> "Compiling JsonPath: " + interpreted);

        final var ast = interpreted.ast();
        final var originalPath = interpreted.toString();

        // Generate a unique class name
        final var className = generateClassName();
        LOG.finer(() -> "Generated class name: " + className);

        // Generate the Java source code
        final var sourceCode = generateSourceCode(className, ast);
        LOG.finer(() -> "Generated source code:\n" + sourceCode);

        // Compile the source code
        final var executor = compileAndInstantiate(className, sourceCode);

        return new JsonPathCompiled(ast, executor, originalPath);
    }

    /// Generates a unique class name for the compiled JsonPath executor.
    private static synchronized String generateClassName() {
        return "JsonPathExecutor_" + (classCounter++);
    }

    /// Generates Java source code that implements the JsonPath query.
    static String generateSourceCode(String className, JsonPathAst.Root ast) {
        final var sb = new StringBuilder();

        // Package and imports
        sb.append("""
                package json.java21.jsonpath.generated;

                import jdk.sandbox.java.util.json.*;
                import json.java21.jsonpath.JsonPathCompiled.JsonPathExecutor;
                import java.util.*;

                public final class %s implements JsonPathExecutor {

                    @Override
                    public List<JsonValue> execute(JsonValue current, JsonValue root) {
                        final var results = new ArrayList<JsonValue>();
                """.formatted(className));

        // Generate the evaluation code
        generateSegmentEvaluation(sb, ast.segments(), 0, "current", "root", "results");

        // Close the execute method and add helper methods
        sb.append("""
                        return results;
                    }

                    // Helper methods for generated code

                    private static int normalizeIdx(int index, int size) {
                        return index < 0 ? size + index : index;
                    }

                    private static JsonValue getPath(JsonValue current, String... props) {
                        JsonValue value = current;
                        for (String prop : props) {
                            if (value instanceof JsonObject obj) {
                                value = obj.members().get(prop);
                                if (value == null) return null;
                            } else {
                                return null;
                            }
                        }
                        return value;
                    }

                    private static Object toComparable(JsonValue value) {
                        if (value == null) return null;
                        if (value instanceof JsonString s) return s.string();
                        if (value instanceof JsonNumber n) return n.toDouble();
                        if (value instanceof JsonBoolean b) return b.bool();
                        if (value instanceof JsonNull) return null;
                        return value;
                    }

                    private static boolean compareValues(Object left, String op, Object right) {
                        if (left == null || right == null) {
                            return switch (op) {
                                case "EQ" -> left == right;
                                case "NE" -> left != right;
                                default -> false;
                            };
                        }

                        if (left instanceof Number ln && right instanceof Number rn) {
                            double l = ln.doubleValue();
                            double r = rn.doubleValue();
                            return switch (op) {
                                case "EQ" -> l == r;
                                case "NE" -> l != r;
                                case "LT" -> l < r;
                                case "LE" -> l <= r;
                                case "GT" -> l > r;
                                case "GE" -> l >= r;
                                default -> false;
                            };
                        }

                        if (left instanceof String && right instanceof String) {
                            @SuppressWarnings("unchecked")
                            int cmp = ((Comparable<Object>) left).compareTo(right);
                            return switch (op) {
                                case "EQ" -> cmp == 0;
                                case "NE" -> cmp != 0;
                                case "LT" -> cmp < 0;
                                case "LE" -> cmp <= 0;
                                case "GT" -> cmp > 0;
                                case "GE" -> cmp >= 0;
                                default -> false;
                            };
                        }

                        if (left instanceof Boolean && right instanceof Boolean) {
                            return switch (op) {
                                case "EQ" -> left.equals(right);
                                case "NE" -> !left.equals(right);
                                default -> false;
                            };
                        }

                        return switch (op) {
                            case "EQ" -> left.equals(right);
                            case "NE" -> !left.equals(right);
                            default -> false;
                        };
                    }
                }
                """);

        return sb.toString();
    }

    /// Generates evaluation code for a sequence of segments.
    private static void generateSegmentEvaluation(
            StringBuilder sb,
            List<JsonPathAst.Segment> segments,
            int segmentIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        // If we've processed all segments, add current to results
        if (segmentIndex >= segments.size()) {
            sb.append("        %s.add(%s);\n".formatted(resultsVar, currentVar));
            return;
        }

        final var segment = segments.get(segmentIndex);
        final var nextIndex = segmentIndex + 1;

        switch (segment) {
            case JsonPathAst.PropertyAccess prop ->
                    generatePropertyAccess(sb, prop, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ArrayIndex arr ->
                    generateArrayIndex(sb, arr, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ArraySlice slice ->
                    generateArraySlice(sb, slice, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Wildcard ignored ->
                    generateWildcard(sb, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.RecursiveDescent desc ->
                    generateRecursiveDescent(sb, desc, segments, segmentIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Filter filter ->
                    generateFilter(sb, filter, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.Union union ->
                    generateUnion(sb, union, segments, nextIndex, currentVar, rootVar, resultsVar);

            case JsonPathAst.ScriptExpression script ->
                    generateScriptExpression(sb, script, segments, nextIndex, currentVar, rootVar, resultsVar);
        }
    }

    private static void generatePropertyAccess(
            StringBuilder sb,
            JsonPathAst.PropertyAccess prop,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var tempVar = "v" + nextIndex;
        sb.append("        if (%s instanceof JsonObject obj%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var %s = obj%d.members().get(\"%s\");\n"
                .formatted(tempVar, nextIndex, escapeJavaString(prop.name())));
        sb.append("            if (%s != null) {\n".formatted(tempVar));
        generateSegmentEvaluation(sb, segments, nextIndex, tempVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateArrayIndex(
            StringBuilder sb,
            JsonPathAst.ArrayIndex arr,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var tempVar = "e" + nextIndex;
        final var idxVar = "idx" + nextIndex;
        sb.append("        if (%s instanceof JsonArray arr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var elements%d = arr%d.elements();\n".formatted(nextIndex, nextIndex));
        sb.append("            int %s = %d;\n".formatted(idxVar, arr.index()));
        sb.append("            if (%s < 0) %s = elements%d.size() + %s;\n".formatted(idxVar, idxVar, nextIndex, idxVar));
        sb.append("            if (%s >= 0 && %s < elements%d.size()) {\n".formatted(idxVar, idxVar, nextIndex));
        sb.append("                final var %s = elements%d.get(%s);\n".formatted(tempVar, nextIndex, idxVar));
        generateSegmentEvaluation(sb, segments, nextIndex, tempVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateArraySlice(
            StringBuilder sb,
            JsonPathAst.ArraySlice slice,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        sb.append("        if (%s instanceof JsonArray arr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            final var elements%d = arr%d.elements();\n".formatted(nextIndex, nextIndex));
        sb.append("            final int size%d = elements%d.size();\n".formatted(nextIndex, nextIndex));

        final int step = slice.step() != null ? slice.step() : 1;
        sb.append("            final int step%d = %d;\n".formatted(nextIndex, step));

        if (step > 0) {
            final var startExpr = slice.start() != null ?
                    "normalizeIdx(%d, size%d)".formatted(slice.start(), nextIndex) : "0";
            final var endExpr = slice.end() != null ?
                    "normalizeIdx(%d, size%d)".formatted(slice.end(), nextIndex) : "size" + nextIndex;

            sb.append("            int start%d = %s;\n".formatted(nextIndex, startExpr));
            sb.append("            int end%d = %s;\n".formatted(nextIndex, endExpr));
            sb.append("            start%d = Math.max(0, Math.min(start%d, size%d));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            end%d = Math.max(0, Math.min(end%d, size%d));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            for (int i%d = start%d; i%d < end%d; i%d += step%d) {\n"
                    .formatted(nextIndex, nextIndex, nextIndex, nextIndex, nextIndex, nextIndex));
        } else {
            final var startExpr = slice.start() != null ?
                    "normalizeIdx(%d, size%d)".formatted(slice.start(), nextIndex) : "size%d - 1".formatted(nextIndex);
            final var endExpr = slice.end() != null ?
                    "normalizeIdx(%d, size%d)".formatted(slice.end(), nextIndex) : "-1";

            sb.append("            int start%d = %s;\n".formatted(nextIndex, startExpr));
            sb.append("            int end%d = %s;\n".formatted(nextIndex, endExpr));
            sb.append("            start%d = Math.max(0, Math.min(start%d, size%d - 1));\n".formatted(nextIndex, nextIndex, nextIndex));
            sb.append("            for (int i%d = start%d; i%d > end%d; i%d += step%d) {\n"
                    .formatted(nextIndex, nextIndex, nextIndex, nextIndex, nextIndex, nextIndex));
        }

        final var elemVar = "elem" + nextIndex;
        sb.append("                final var %s = elements%d.get(i%d);\n".formatted(elemVar, nextIndex, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateWildcard(
            StringBuilder sb,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var elemVar = "wc" + nextIndex;
        sb.append("        if (%s instanceof JsonObject wobj%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : wobj%d.members().values()) {\n".formatted(elemVar, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        } else if (%s instanceof JsonArray warr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : warr%d.elements()) {\n".formatted(elemVar, nextIndex));
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateRecursiveDescent(
            StringBuilder sb,
            JsonPathAst.RecursiveDescent desc,
            List<JsonPathAst.Segment> segments,
            int segmentIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        // For recursive descent, we generate a helper method call
        // For now, fall back to interpreter for complex recursive descent
        sb.append("        // Recursive descent - delegating to interpreter\n");
        sb.append("        json.java21.jsonpath.JsonPathInterpreted.evaluateRecursiveDescent(\n");
        sb.append("            new json.java21.jsonpath.JsonPathAst.RecursiveDescent(");
        generateAstLiteral(sb, desc.target());
        sb.append("),\n");
        sb.append("            java.util.List.of(");
        for (int i = segmentIndex; i < segments.size(); i++) {
            if (i > segmentIndex) sb.append(", ");
            generateAstLiteral(sb, segments.get(i));
        }
        sb.append("),\n");
        sb.append("            %d, %s, %s, %s);\n".formatted(segmentIndex, currentVar, rootVar, resultsVar));
    }

    private static void generateFilter(
            StringBuilder sb,
            JsonPathAst.Filter filter,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        final var elemVar = "fe" + nextIndex;
        sb.append("        if (%s instanceof JsonArray farr%d) {\n".formatted(currentVar, nextIndex));
        sb.append("            for (final var %s : farr%d.elements()) {\n".formatted(elemVar, nextIndex));
        sb.append("                if (");
        generateFilterCondition(sb, filter.expression(), elemVar);
        sb.append(") {\n");
        generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
        sb.append("                }\n");
        sb.append("            }\n");
        sb.append("        }\n");
    }

    private static void generateFilterCondition(StringBuilder sb, JsonPathAst.FilterExpression expr, String currentVar) {
        switch (expr) {
            case JsonPathAst.ExistsFilter exists -> {
                generatePropertyPathAccess(sb, exists.path(), currentVar);
                sb.append(" != null");
            }
            case JsonPathAst.ComparisonFilter comp -> {
                sb.append("compareValues(");
                generateFilterValue(sb, comp.left(), currentVar);
                sb.append(", \"").append(comp.op().name()).append("\", ");
                generateFilterValue(sb, comp.right(), currentVar);
                sb.append(")");
            }
            case JsonPathAst.LogicalFilter logical -> {
                switch (logical.op()) {
                    case AND -> {
                        sb.append("(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(" && ");
                        generateFilterCondition(sb, logical.right(), currentVar);
                        sb.append(")");
                    }
                    case OR -> {
                        sb.append("(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(" || ");
                        generateFilterCondition(sb, logical.right(), currentVar);
                        sb.append(")");
                    }
                    case NOT -> {
                        sb.append("!(");
                        generateFilterCondition(sb, logical.left(), currentVar);
                        sb.append(")");
                    }
                }
            }
            case JsonPathAst.CurrentNode ignored -> sb.append("true");
            case JsonPathAst.PropertyPath path -> {
                generatePropertyPathAccess(sb, path, currentVar);
                sb.append(" != null");
            }
            case JsonPathAst.LiteralValue ignored -> sb.append("true");
        }
    }

    private static void generatePropertyPathAccess(StringBuilder sb, JsonPathAst.PropertyPath path, String currentVar) {
        sb.append("getPath(%s".formatted(currentVar));
        for (final var prop : path.properties()) {
            sb.append(", \"").append(escapeJavaString(prop)).append("\"");
        }
        sb.append(")");
    }

    private static void generateFilterValue(StringBuilder sb, JsonPathAst.FilterExpression expr, String currentVar) {
        switch (expr) {
            case JsonPathAst.PropertyPath path -> {
                sb.append("toComparable(");
                generatePropertyPathAccess(sb, path, currentVar);
                sb.append(")");
            }
            case JsonPathAst.LiteralValue lit -> {
                if (lit.value() == null) {
                    sb.append("null");
                } else if (lit.value() instanceof String s) {
                    sb.append("\"").append(escapeJavaString(s)).append("\"");
                } else if (lit.value() instanceof Number n) {
                    sb.append(n.doubleValue());
                } else if (lit.value() instanceof Boolean b) {
                    sb.append(b);
                } else {
                    sb.append("null");
                }
            }
            case JsonPathAst.CurrentNode ignored ->
                    sb.append("toComparable(%s)".formatted(currentVar));
            default -> sb.append("null");
        }
    }

    private static void generateUnion(
            StringBuilder sb,
            JsonPathAst.Union union,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        for (final var selector : union.selectors()) {
            switch (selector) {
                case JsonPathAst.ArrayIndex arr ->
                        generateArrayIndex(sb, arr, segments, nextIndex, currentVar, rootVar, resultsVar);
                case JsonPathAst.PropertyAccess prop ->
                        generatePropertyAccess(sb, prop, segments, nextIndex, currentVar, rootVar, resultsVar);
                default -> {
                    // Unsupported selector, skip
                }
            }
        }
    }

    private static void generateScriptExpression(
            StringBuilder sb,
            JsonPathAst.ScriptExpression script,
            List<JsonPathAst.Segment> segments,
            int nextIndex,
            String currentVar,
            String rootVar,
            String resultsVar) {

        // Only support @.length-1 pattern for now
        if (script.script().trim().equals("@.length-1")) {
            sb.append("        if (%s instanceof JsonArray sarr%d) {\n".formatted(currentVar, nextIndex));
            sb.append("            final int lastIdx%d = sarr%d.elements().size() - 1;\n".formatted(nextIndex, nextIndex));
            sb.append("            if (lastIdx%d >= 0) {\n".formatted(nextIndex));
            final var elemVar = "se" + nextIndex;
            sb.append("                final var %s = sarr%d.elements().get(lastIdx%d);\n".formatted(elemVar, nextIndex, nextIndex));
            generateSegmentEvaluation(sb, segments, nextIndex, elemVar, rootVar, resultsVar);
            sb.append("            }\n");
            sb.append("        }\n");
        } else {
            // Unsupported script, delegate to interpreter
            sb.append("        // Unsupported script expression - delegating to interpreter\n");
            sb.append("        json.java21.jsonpath.JsonPathInterpreted.evaluateScriptExpression(\n");
            sb.append("            new json.java21.jsonpath.JsonPathAst.ScriptExpression(\"");
            sb.append(escapeJavaString(script.script()));
            sb.append("\"),\n");
            sb.append("            java.util.List.of(");
            for (int i = nextIndex - 1; i < segments.size(); i++) {
                if (i > nextIndex - 1) sb.append(", ");
                generateAstLiteral(sb, segments.get(i));
            }
            sb.append("),\n");
            sb.append("            %d, %s, %s, %s);\n".formatted(nextIndex - 1, currentVar, rootVar, resultsVar));
        }
    }

    private static void generateAstLiteral(StringBuilder sb, JsonPathAst.Segment segment) {
        switch (segment) {
            case JsonPathAst.PropertyAccess prop ->
                    sb.append("new json.java21.jsonpath.JsonPathAst.PropertyAccess(\"")
                            .append(escapeJavaString(prop.name())).append("\")");
            case JsonPathAst.ArrayIndex arr ->
                    sb.append("new json.java21.jsonpath.JsonPathAst.ArrayIndex(").append(arr.index()).append(")");
            case JsonPathAst.Wildcard ignored ->
                    sb.append("new json.java21.jsonpath.JsonPathAst.Wildcard()");
            case JsonPathAst.ArraySlice slice -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.ArraySlice(");
                sb.append(slice.start() == null ? "null" : slice.start()).append(", ");
                sb.append(slice.end() == null ? "null" : slice.end()).append(", ");
                sb.append(slice.step() == null ? "null" : slice.step()).append(")");
            }
            case JsonPathAst.RecursiveDescent desc -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.RecursiveDescent(");
                generateAstLiteral(sb, desc.target());
                sb.append(")");
            }
            case JsonPathAst.Filter filter -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.Filter(");
                generateFilterExprLiteral(sb, filter.expression());
                sb.append(")");
            }
            case JsonPathAst.Union union -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.Union(java.util.List.of(");
                final var selectors = union.selectors();
                for (int i = 0; i < selectors.size(); i++) {
                    if (i > 0) sb.append(", ");
                    generateAstLiteral(sb, selectors.get(i));
                }
                sb.append("))");
            }
            case JsonPathAst.ScriptExpression script ->
                    sb.append("new json.java21.jsonpath.JsonPathAst.ScriptExpression(\"")
                            .append(escapeJavaString(script.script())).append("\")");
        }
    }

    private static void generateFilterExprLiteral(StringBuilder sb, JsonPathAst.FilterExpression expr) {
        switch (expr) {
            case JsonPathAst.ExistsFilter exists -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.ExistsFilter(");
                generateFilterExprLiteral(sb, exists.path());
                sb.append(")");
            }
            case JsonPathAst.ComparisonFilter comp -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.ComparisonFilter(");
                generateFilterExprLiteral(sb, comp.left());
                sb.append(", json.java21.jsonpath.JsonPathAst.ComparisonOp.").append(comp.op().name()).append(", ");
                generateFilterExprLiteral(sb, comp.right());
                sb.append(")");
            }
            case JsonPathAst.LogicalFilter logical -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.LogicalFilter(");
                generateFilterExprLiteral(sb, logical.left());
                sb.append(", json.java21.jsonpath.JsonPathAst.LogicalOp.").append(logical.op().name()).append(", ");
                if (logical.right() != null) {
                    generateFilterExprLiteral(sb, logical.right());
                } else {
                    sb.append("null");
                }
                sb.append(")");
            }
            case JsonPathAst.CurrentNode ignored ->
                    sb.append("new json.java21.jsonpath.JsonPathAst.CurrentNode()");
            case JsonPathAst.PropertyPath path -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.PropertyPath(java.util.List.of(");
                for (int i = 0; i < path.properties().size(); i++) {
                    if (i > 0) sb.append(", ");
                    sb.append("\"").append(escapeJavaString(path.properties().get(i))).append("\"");
                }
                sb.append("))");
            }
            case JsonPathAst.LiteralValue lit -> {
                sb.append("new json.java21.jsonpath.JsonPathAst.LiteralValue(");
                if (lit.value() == null) {
                    sb.append("null");
                } else if (lit.value() instanceof String s) {
                    sb.append("\"").append(escapeJavaString(s)).append("\"");
                } else if (lit.value() instanceof Number n) {
                    if (lit.value() instanceof Long l) {
                        sb.append(l).append("L");
                    } else {
                        sb.append(n.doubleValue());
                    }
                } else if (lit.value() instanceof Boolean b) {
                    sb.append(b);
                }
                sb.append(")");
            }
        }
    }

    /// Compiles the generated source code and instantiates the executor.
    private static JsonPathCompiled.JsonPathExecutor compileAndInstantiate(String className, String sourceCode) {
        final var compiler = ToolProvider.getSystemJavaCompiler();
        if (compiler == null) {
            LOG.warning(() -> "No Java compiler available - falling back to interpreter delegation");
            throw new RuntimeException("Java compiler not available. Ensure you're running with a JDK, not a JRE.");
        }

        final var fileManager = new InMemoryFileManager(compiler.getStandardFileManager(null, null, StandardCharsets.UTF_8));

        // Create a source file object
        final var fullClassName = "json.java21.jsonpath.generated." + className;
        final var sourceFile = new InMemoryJavaFileObject(fullClassName, sourceCode);

        // Compile the source
        final var diagnostics = new DiagnosticCollector<JavaFileObject>();
        final var compilationUnits = Collections.singletonList(sourceFile);
        final var options = List.of(
                "-classpath", System.getProperty("java.class.path"),
                "--add-exports", "json.java21.jsonpath/json.java21.jsonpath=ALL-UNNAMED",
                "--add-exports", "json.java21/jdk.sandbox.java.util.json=ALL-UNNAMED"
        );

        final var task = compiler.getTask(null, fileManager, diagnostics, options, null, compilationUnits);
        final boolean success = task.call();

        if (!success) {
            final var errors = new StringBuilder("Compilation failed:\n");
            for (final var diagnostic : diagnostics.getDiagnostics()) {
                errors.append(diagnostic.toString()).append("\n");
            }
            errors.append("\nSource code:\n").append(sourceCode);
            LOG.severe(() -> "ERROR: " + errors);
            throw new RuntimeException(errors.toString());
        }

        // Load and instantiate the compiled class
        try {
            final var classLoader = new InMemoryClassLoader(fileManager.getClassBytes());
            final var clazz = classLoader.loadClass(fullClassName);
            return (JsonPathCompiled.JsonPathExecutor) clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate compiled JsonPath executor", e);
        }
    }

    private static String escapeJavaString(String s) {
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    /// In-memory Java source file object for compilation.
    private static final class InMemoryJavaFileObject extends SimpleJavaFileObject {
        private final String code;

        InMemoryJavaFileObject(String className, String code) {
            super(URI.create("string:///" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
            this.code = code;
        }

        @Override
        public CharSequence getCharContent(boolean ignoreEncodingErrors) {
            return code;
        }
    }

    /// In-memory class file object for capturing compiled bytecode.
    private static final class InMemoryClassFileObject extends SimpleJavaFileObject {
        private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        InMemoryClassFileObject(String className) {
            super(URI.create("mem:///" + className.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
        }

        @Override
        public OutputStream openOutputStream() {
            return outputStream;
        }

        byte[] getBytes() {
            return outputStream.toByteArray();
        }
    }

    /// In-memory file manager that captures compiled class files.
    private static final class InMemoryFileManager extends ForwardingJavaFileManager<StandardJavaFileManager> {
        private final Map<String, InMemoryClassFileObject> classFiles = new HashMap<>();

        InMemoryFileManager(StandardJavaFileManager fileManager) {
            super(fileManager);
        }

        @Override
        public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) {
            if (kind == JavaFileObject.Kind.CLASS) {
                final var classFile = new InMemoryClassFileObject(className);
                classFiles.put(className, classFile);
                return classFile;
            }
            return null;
        }

        Map<String, byte[]> getClassBytes() {
            final var result = new HashMap<String, byte[]>();
            for (final var entry : classFiles.entrySet()) {
                result.put(entry.getKey(), entry.getValue().getBytes());
            }
            return result;
        }
    }

    /// Class loader that loads compiled classes from memory.
    private static final class InMemoryClassLoader extends ClassLoader {
        private final Map<String, byte[]> classBytes;

        InMemoryClassLoader(Map<String, byte[]> classBytes) {
            super(JsonPathCompiler.class.getClassLoader());
            this.classBytes = classBytes;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            final var bytes = classBytes.get(name);
            if (bytes != null) {
                return defineClass(name, bytes, 0, bytes.length);
            }
            return super.findClass(name);
        }
    }
}
