package json.java21.jdt;

import jdk.sandbox.java.util.json.JsonValue;
import json.java21.jdt.JdtAst.*;

import java.util.Map;
import java.util.logging.Logger;

/// Renders a JDT AST into an ES2020 module that exports a `transform(source)` function.
///
/// The generated JavaScript applies the transform specification to a source document
/// without interpretation overhead - all directive dispatch is resolved at render time.
///
/// Usage:
/// ```java
/// var ast = Jdt.parseToAst(transformJson);
/// String esm = JdtEsmRenderer.render(ast);
/// // esm contains: export function transform(source) { ... }
/// ```
public final class JdtEsmRenderer {

    private static final Logger LOG = Logger.getLogger(JdtEsmRenderer.class.getName());

    private JdtEsmRenderer() {}

    /// Renders a JDT AST into an ES2020 module string.
    ///
    /// @param ast the parsed JDT AST root node
    /// @return a complete ES2020 module string
    public static String render(JdtNode ast) {
        final var sb = new StringBuilder();

        sb.append("// Generated JDT (JSON Document Transform)\n");
        sb.append("// Do not edit - generated by JdtEsmRenderer\n\n");

        // Emit helper functions
        sb.append("function deepMerge(source, overlay) {\n");
        sb.append("  if (typeof source !== 'object' || source === null || Array.isArray(source)) return overlay;\n");
        sb.append("  if (typeof overlay !== 'object' || overlay === null || Array.isArray(overlay)) return overlay;\n");
        sb.append("  const result = { ...source };\n");
        sb.append("  for (const [k, v] of Object.entries(overlay)) {\n");
        sb.append("    if (typeof result[k] === 'object' && result[k] !== null && !Array.isArray(result[k])\n");
        sb.append("        && typeof v === 'object' && v !== null && !Array.isArray(v)) {\n");
        sb.append("      result[k] = deepMerge(result[k], v);\n");
        sb.append("    } else if (Array.isArray(result[k]) && Array.isArray(v)) {\n");
        sb.append("      result[k] = [...result[k], ...v];\n");
        sb.append("    } else {\n");
        sb.append("      result[k] = v;\n");
        sb.append("    }\n");
        sb.append("  }\n");
        sb.append("  return result;\n");
        sb.append("}\n\n");

        sb.append("export function transform(source) {\n");
        emitNode(sb, ast, "source", "  ");
        sb.append("}\n");

        LOG.fine(() -> "Rendered JDT ESM module");
        return sb.toString();
    }

    private static void emitNode(StringBuilder sb, JdtNode node, String sourceVar, String indent) {
        switch (node) {
            case ReplacementNode rep -> {
                sb.append(indent).append("return ").append(jsonToJs(rep.value())).append(";\n");
            }
            case MergeNode merge -> {
                emitMergeNode(sb, merge, sourceVar, indent);
            }
            case DirectiveNode dir -> {
                emitDirectiveNode(sb, dir, sourceVar, indent);
            }
        }
    }

    private static void emitMergeNode(StringBuilder sb, MergeNode merge, String sourceVar, String indent) {
        if (merge.children().isEmpty()) {
            sb.append(indent).append("return ").append(sourceVar).append(";\n");
            return;
        }

        // Build overlay object from children
        sb.append(indent).append("const _overlay = {};\n");
        for (final var entry : merge.children().entrySet()) {
            final var key = entry.getKey();
            final var child = entry.getValue();
            switch (child) {
                case ReplacementNode rep ->
                    sb.append(indent).append("_overlay[").append(jsString(key)).append("] = ")
                      .append(jsonToJs(rep.value())).append(";\n");
                case MergeNode childMerge -> {
                    final var childVar = sourceVar + "?.[" + jsString(key) + "]";
                    final var fnName = "_merge_" + sanitize(key);
                    sb.append(indent).append("function ").append(fnName).append("(_s) {\n");
                    emitMergeNode(sb, childMerge, "_s", indent + "  ");
                    sb.append(indent).append("}\n");
                    sb.append(indent).append("_overlay[").append(jsString(key)).append("] = ")
                      .append(fnName).append("(").append(childVar).append(" ?? {});\n");
                }
                case DirectiveNode childDir -> {
                    final var childVar = sourceVar + "?.[" + jsString(key) + "]";
                    final var fnName = "_apply_" + sanitize(key);
                    sb.append(indent).append("function ").append(fnName).append("(_s) {\n");
                    emitDirectiveNode(sb, childDir, "_s", indent + "  ");
                    sb.append(indent).append("}\n");
                    sb.append(indent).append("_overlay[").append(jsString(key)).append("] = ")
                      .append(fnName).append("(").append(childVar).append(" ?? {});\n");
                }
            }
        }
        sb.append(indent).append("return deepMerge(").append(sourceVar).append(", _overlay);\n");
    }

    private static void emitDirectiveNode(StringBuilder sb, DirectiveNode dir, String sourceVar, String indent) {
        sb.append(indent).append("let _r = ").append(sourceVar).append(";\n");

        // 1. Rename
        if (dir.rename() != null) {
            emitRename(sb, dir.rename(), indent);
        }

        // 2. Remove
        if (dir.remove() != null) {
            emitRemove(sb, dir.remove(), indent);
        }

        // 3. Merge
        if (dir.merge() != null) {
            emitMerge(sb, dir.merge(), indent);
        }

        // 4. Replace
        if (dir.replace() != null) {
            emitReplace(sb, dir.replace(), indent);
        }

        // Process children as default merge
        for (final var entry : dir.children().entrySet()) {
            final var key = entry.getKey();
            final var child = entry.getValue();
            switch (child) {
                case ReplacementNode rep ->
                    sb.append(indent).append("if (typeof _r === 'object' && _r !== null) ")
                      .append("_r[").append(jsString(key)).append("] = ")
                      .append(jsonToJs(rep.value())).append(";\n");
                default ->
                    sb.append(indent).append("if (typeof _r === 'object' && _r !== null && _r[")
                      .append(jsString(key)).append("] !== undefined) _r[").append(jsString(key))
                      .append("] = deepMerge(_r[").append(jsString(key)).append("], ")
                      .append(jsonToJs(child)).append(");\n");
            }
        }

        sb.append(indent).append("return _r;\n");
    }

    private static void emitRename(StringBuilder sb, JsonValue renameSpec, String indent) {
        sb.append(indent).append("if (typeof _r === 'object' && _r !== null) {\n");
        if (renameSpec instanceof jdk.sandbox.java.util.json.JsonObject renameObj) {
            for (final var entry : renameObj.members().entrySet()) {
                if (entry.getKey().startsWith("@jdt.")) continue;
                if (entry.getValue() instanceof jdk.sandbox.java.util.json.JsonString newNameStr) {
                    sb.append(indent).append("  if (").append(jsString(entry.getKey())).append(" in _r) {\n");
                    sb.append(indent).append("    _r[").append(jsString(newNameStr.string()))
                      .append("] = _r[").append(jsString(entry.getKey())).append("];\n");
                    sb.append(indent).append("    delete _r[").append(jsString(entry.getKey())).append("];\n");
                    sb.append(indent).append("  }\n");
                }
            }
        }
        sb.append(indent).append("}\n");
    }

    private static void emitRemove(StringBuilder sb, JsonValue removeSpec, String indent) {
        sb.append(indent).append("if (typeof _r === 'object' && _r !== null) {\n");
        if (removeSpec instanceof jdk.sandbox.java.util.json.JsonString removeStr) {
            sb.append(indent).append("  delete _r[").append(jsString(removeStr.string())).append("];\n");
        } else if (removeSpec instanceof jdk.sandbox.java.util.json.JsonBoolean removeBool && removeBool.bool()) {
            sb.append(indent).append("  _r = null;\n");
        } else if (removeSpec instanceof jdk.sandbox.java.util.json.JsonArray removeArr) {
            for (final var item : removeArr.elements()) {
                if (item instanceof jdk.sandbox.java.util.json.JsonString itemStr) {
                    sb.append(indent).append("  delete _r[").append(jsString(itemStr.string())).append("];\n");
                }
            }
        }
        sb.append(indent).append("}\n");
    }

    private static void emitMerge(StringBuilder sb, JsonValue mergeSpec, String indent) {
        sb.append(indent).append("_r = deepMerge(_r, ").append(jsonToJs(mergeSpec)).append(");\n");
    }

    private static void emitReplace(StringBuilder sb, JsonValue replaceSpec, String indent) {
        sb.append(indent).append("_r = ").append(jsonToJs(replaceSpec)).append(";\n");
    }

    private static String jsonToJs(Object value) {
        if (value instanceof JdtNode) return "{}"; // Fallback for AST nodes in children
        if (value instanceof JsonValue jv) return jv.toString();
        return "null";
    }

    private static String jsString(String s) {
        return "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
    }

    private static String sanitize(String s) {
        return s.replaceAll("[^a-zA-Z0-9_]", "_");
    }
}
