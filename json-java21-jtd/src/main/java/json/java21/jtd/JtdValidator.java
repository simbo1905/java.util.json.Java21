package json.java21.jtd;

import jdk.sandbox.java.util.json.JsonValue;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Objects;
import java.util.logging.Logger;

/// Functional interface for validating a JSON instance against a compiled JTD schema.
///
/// Obtain an instance via the static factory methods:
/// - [#compile(JsonValue)] -- interpreter path, always available.
/// - [#compileGenerated(JsonValue)] -- bytecode-generated path, requires
///   `json-java21-jtd-codegen` on the classpath (JDK 24+ build).
@FunctionalInterface
public interface JtdValidator {

  Logger LOG = Logger.getLogger(JtdValidator.class.getName());

  /// Validates an instance against the compiled schema.
  ///
  /// @param instance the JSON value to validate
  /// @return the validation result with RFC 8927 error pairs
  JtdValidationResult validate(JsonValue instance);

  // ------------------------------------------------------------------
  // Factory: interpreter path (always available)
  // ------------------------------------------------------------------

  /// Compiles a JTD schema into a reusable validator using the stack-machine
  /// interpreter. Works on any JDK 21+ runtime with zero extra dependencies.
  ///
  /// @param schema the JTD schema as a parsed [JsonValue]
  /// @return a reusable [JtdValidator]
  /// @throws IllegalArgumentException if the schema is invalid per RFC 8927
  static JtdValidator compile(JsonValue schema) {
    Objects.requireNonNull(schema, "schema must not be null");
    final var jtd = new Jtd();
    final var compiled = jtd.compileToSchema(schema);
    return new InterpreterValidator(compiled, jtd, schema.toString());
  }

  // ------------------------------------------------------------------
  // Factory: codegen path (optional, requires extra module)
  // ------------------------------------------------------------------

  String CODEGEN_CLASS = "json.java21.jtd.codegen.JtdCodegen";
  String CODEGEN_METHOD = "compile";

  /// Compiles a JTD schema into a bytecode-generated validator.
  /// Requires the `json-java21-jtd-codegen` module on the classpath.
  ///
  /// @param schema the JTD schema as a parsed [JsonValue]
  /// @return a reusable [JtdValidator] backed by generated bytecode
  /// @throws UnsupportedOperationException if the codegen module is not on the classpath
  /// @throws IllegalArgumentException if the schema is invalid per RFC 8927
  static JtdValidator compileGenerated(JsonValue schema) {
    Objects.requireNonNull(schema, "schema must not be null");
    try {
      final var clazz = Class.forName(CODEGEN_CLASS);
      final var method = clazz.getMethod(CODEGEN_METHOD, JsonValue.class);
      return (JtdValidator) method.invoke(null, schema);
    } catch (ClassNotFoundException e) {
      throw new UnsupportedOperationException(
          "Codegen module not on classpath. Add json-java21-jtd-codegen dependency, "
              + "or use JtdValidator.compile() for the interpreter path.", e);
    } catch (InvocationTargetException e) {
      final var cause = e.getCause();
      if (cause instanceof IllegalArgumentException iae) throw iae;
      if (cause instanceof RuntimeException re) throw re;
      throw new RuntimeException("Codegen compilation failed", cause);
    } catch (ReflectiveOperationException e) {
      throw new UnsupportedOperationException("Codegen module found but incompatible", e);
    }
  }
}
