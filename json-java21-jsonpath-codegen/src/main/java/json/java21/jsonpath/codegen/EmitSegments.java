package json.java21.jsonpath.codegen;

import java.lang.classfile.*;
import java.lang.constant.ClassDesc;
import java.lang.constant.ConstantDescs;
import java.lang.constant.MethodTypeDesc;
import java.util.List;

import json.java21.jsonpath.JsonPathAst;
import json.java21.jsonpath.JsonPathAst.*;

import static json.java21.jsonpath.codegen.Descriptors.*;

/// Emits bytecode for the JsonPath segment evaluation chain.
///
/// At codegen time, walks the AST segment list and emits JVM bytecode
/// that evaluates each segment. At runtime, the generated bytecode
/// executes with no interpretation overhead.
///
/// The generated code mirrors the interpreter logic in `JsonPath.evaluateSegments`
/// but with all dispatch decisions resolved at compile time.
final class EmitSegments {

    private EmitSegments() {}

    /// Emits bytecode for a chain of segments starting at the given index.
    ///
    /// @param cob the code builder
    /// @param segments the full segment list from the AST
    /// @param segIdx the current index into the segment list
    /// @param currentSlot local variable slot holding the current JsonValue
    /// @param rootSlot local variable slot holding the root document
    /// @param resultsSlot local variable slot holding the ArrayList of results
    static void emitSegmentChain(CodeBuilder cob, List<Segment> segments,
            int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        // Base case: all segments consumed -> add current to results
        if (segIdx >= segments.size()) {
            cob.aload(resultsSlot);
            cob.aload(currentSlot);
            cob.invokevirtual(CD_ArrayList, "add", MTD_boolean_Object);
            cob.pop(); // discard boolean return
            return;
        }

        final var segment = segments.get(segIdx);

        switch (segment) {
            case PropertyAccess prop ->
                emitPropertyAccess(cob, prop, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case ArrayIndex arr ->
                emitArrayIndex(cob, arr, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case ArraySlice slice ->
                emitArraySlice(cob, slice, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case Wildcard _ ->
                emitWildcard(cob, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case RecursiveDescent desc ->
                emitRecursiveDescent(cob, desc, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case Filter filter ->
                emitFilter(cob, filter, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case Union union ->
                emitUnion(cob, union, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            case ScriptExpression script ->
                emitScript(cob, script, segments, segIdx, currentSlot, rootSlot, resultsSlot);
        }
    }

    /// PropertyAccess: if current instanceof JsonObject, get member by name, recurse
    private static void emitPropertyAccess(CodeBuilder cob, PropertyAccess prop,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        var end = cob.newLabel();

        // if (!(current instanceof JsonObject)) skip
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonObject);
        cob.ifeq(end);

        // JsonObject obj = (JsonObject) current
        cob.aload(currentSlot);
        cob.checkcast(CD_JsonObject);
        // obj.members()
        cob.invokeinterface(CD_JsonObject, "members", MTD_Map);
        // map.get(name)
        cob.ldc(prop.name());
        cob.invokeinterface(CD_Map, "get", MTD_Object_Object);

        // if (value == null) skip
        int valueSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(valueSlot);
        cob.aload(valueSlot);
        cob.ifnull(end);

        // Cast to JsonValue and recurse with next segment
        cob.aload(valueSlot);
        cob.checkcast(CD_JsonValue);
        int childSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(childSlot);

        emitSegmentChain(cob, segments, segIdx + 1, childSlot, rootSlot, resultsSlot);

        cob.labelBinding(end);
    }

    /// ArrayIndex: if current instanceof JsonArray, normalize index, get element, recurse
    private static void emitArrayIndex(CodeBuilder cob, ArrayIndex arr,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        var end = cob.newLabel();

        // if (!(current instanceof JsonArray)) skip
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonArray);
        cob.ifeq(end);

        // JsonArray jarr = (JsonArray) current
        cob.aload(currentSlot);
        cob.checkcast(CD_JsonArray);
        // jarr.elements() -> List
        cob.invokeinterface(CD_JsonArray, "elements", MTD_List);
        int listSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(listSlot);

        // int size = list.size()
        cob.aload(listSlot);
        cob.invokeinterface(CD_List, "size", MTD_int);
        int sizeSlot = cob.allocateLocal(TypeKind.INT);
        cob.istore(sizeSlot);

        // Normalize index: idx < 0 ? idx + size : idx
        int idx = arr.index();
        int idxSlot = cob.allocateLocal(TypeKind.INT);
        if (idx < 0) {
            cob.iload(sizeSlot);
            cob.ldc(-idx);
            cob.isub();
            cob.istore(idxSlot);
        } else {
            cob.ldc(idx);
            cob.istore(idxSlot);
        }

        // Bounds check: if (normalizedIdx < 0 || normalizedIdx >= size) skip
        cob.iload(idxSlot);
        cob.iflt(end);
        cob.iload(idxSlot);
        cob.iload(sizeSlot);
        cob.if_icmpge(end);

        // Object elem = list.get(normalizedIdx)
        cob.aload(listSlot);
        cob.iload(idxSlot);
        cob.invokeinterface(CD_List, "get", MTD_Object_int);
        cob.checkcast(CD_JsonValue);
        int elemSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(elemSlot);

        emitSegmentChain(cob, segments, segIdx + 1, elemSlot, rootSlot, resultsSlot);

        cob.labelBinding(end);
    }

    /// ArraySlice: iterate slice range, recurse each element
    private static void emitArraySlice(CodeBuilder cob, ArraySlice slice,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        var end = cob.newLabel();

        // if (!(current instanceof JsonArray)) skip
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonArray);
        cob.ifeq(end);

        cob.aload(currentSlot);
        cob.checkcast(CD_JsonArray);
        cob.invokeinterface(CD_JsonArray, "elements", MTD_List);
        int listSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(listSlot);

        cob.aload(listSlot);
        cob.invokeinterface(CD_List, "size", MTD_int);
        int sizeSlot = cob.allocateLocal(TypeKind.INT);
        cob.istore(sizeSlot);

        // Determine step (default 1)
        int step = slice.step() != null ? slice.step() : 1;
        if (step == 0) {
            cob.labelBinding(end);
            return; // step of 0 is a no-op
        }

        // For positive step: start defaults to 0, end defaults to size
        // For negative step: start defaults to size-1, end defaults to -size-1
        // We emit runtime computations for the normalize

        int iSlot = cob.allocateLocal(TypeKind.INT);
        var loopHead = cob.newLabel();
        var loopEnd = cob.newLabel();

        if (step > 0) {
            // start
            if (slice.start() != null) {
                emitNormalizeIndex(cob, slice.start(), sizeSlot);
                // clamp to 0
                cob.ldc(0);
                cob.invokestatic(ClassDesc.of("java.lang.Math"), "max",
                    MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int));
            } else {
                cob.ldc(0);
            }
            cob.istore(iSlot);

            // end
            int endSlot = cob.allocateLocal(TypeKind.INT);
            if (slice.end() != null) {
                emitNormalizeIndex(cob, slice.end(), sizeSlot);
                // clamp to size
                cob.iload(sizeSlot);
                cob.invokestatic(ClassDesc.of("java.lang.Math"), "min",
                    MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int));
            } else {
                cob.iload(sizeSlot);
            }
            cob.istore(endSlot);

            // for (int i = start; i < end; i += step)
            cob.labelBinding(loopHead);
            cob.iload(iSlot);
            cob.iload(endSlot);
            cob.if_icmpge(loopEnd);

            // element = list.get(i)
            cob.aload(listSlot);
            cob.iload(iSlot);
            cob.invokeinterface(CD_List, "get", MTD_Object_int);
            cob.checkcast(CD_JsonValue);
            int elemSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(elemSlot);

            emitSegmentChain(cob, segments, segIdx + 1, elemSlot, rootSlot, resultsSlot);

            cob.iinc(iSlot, step);
            cob.goto_(loopHead);
            cob.labelBinding(loopEnd);
        } else {
            // Negative step: start defaults to size-1, end defaults to -1 (exclusive)
            if (slice.start() != null) {
                emitNormalizeIndex(cob, slice.start(), sizeSlot);
                // clamp to size-1
                cob.iload(sizeSlot);
                cob.ldc(1);
                cob.isub();
                cob.invokestatic(ClassDesc.of("java.lang.Math"), "min",
                    MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int));
            } else {
                cob.iload(sizeSlot);
                cob.ldc(1);
                cob.isub();
            }
            cob.istore(iSlot);

            int endSlot = cob.allocateLocal(TypeKind.INT);
            if (slice.end() != null) {
                emitNormalizeIndex(cob, slice.end(), sizeSlot);
            } else {
                cob.ldc(-1);
            }
            cob.istore(endSlot);

            // for (int i = start; i > end; i += step)
            cob.labelBinding(loopHead);
            cob.iload(iSlot);
            cob.iload(endSlot);
            cob.if_icmple(loopEnd);

            // bounds check: 0 <= i < size
            cob.iload(iSlot);
            cob.iflt(loopEnd);
            cob.iload(iSlot);
            cob.iload(sizeSlot);
            cob.if_icmpge(loopEnd);

            cob.aload(listSlot);
            cob.iload(iSlot);
            cob.invokeinterface(CD_List, "get", MTD_Object_int);
            cob.checkcast(CD_JsonValue);
            int elemSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(elemSlot);

            emitSegmentChain(cob, segments, segIdx + 1, elemSlot, rootSlot, resultsSlot);

            // i += step (step is negative, so this decrements)
            cob.iload(iSlot);
            cob.ldc(step);
            cob.iadd();
            cob.istore(iSlot);
            cob.goto_(loopHead);
            cob.labelBinding(loopEnd);
        }

        cob.labelBinding(end);
    }

    /// Emits: push (idx < 0 ? idx + size : idx) onto stack
    private static void emitNormalizeIndex(CodeBuilder cob, int idx, int sizeSlot) {
        if (idx < 0) {
            cob.iload(sizeSlot);
            cob.ldc(-idx);
            cob.isub(); // size - abs(idx) = size + idx
        } else {
            cob.ldc(idx);
        }
    }

    /// Wildcard: iterate all children (object values or array elements), recurse each
    private static void emitWildcard(CodeBuilder cob,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        var endObj = cob.newLabel();
        var tryArray = cob.newLabel();
        var end = cob.newLabel();

        // if (current instanceof JsonObject)
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonObject);
        cob.ifeq(tryArray);

        // Iterate object values
        cob.aload(currentSlot);
        cob.checkcast(CD_JsonObject);
        cob.invokeinterface(CD_JsonObject, "members", MTD_Map);
        cob.invokeinterface(CD_Map, "values", MethodTypeDesc.of(CD_Collection));
        cob.invokeinterface(CD_Collection, "iterator", MTD_Iterator);
        int iterSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(iterSlot);

        var objLoopHead = cob.newLabel();
        var objLoopEnd = cob.newLabel();
        cob.labelBinding(objLoopHead);
        cob.aload(iterSlot);
        cob.invokeinterface(CD_Iterator, "hasNext", MTD_boolean);
        cob.ifeq(objLoopEnd);
        cob.aload(iterSlot);
        cob.invokeinterface(CD_Iterator, "next", MTD_Object);
        cob.checkcast(CD_JsonValue);
        int childSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(childSlot);

        emitSegmentChain(cob, segments, segIdx + 1, childSlot, rootSlot, resultsSlot);

        cob.goto_(objLoopHead);
        cob.labelBinding(objLoopEnd);
        cob.goto_(end);

        // if (current instanceof JsonArray)
        cob.labelBinding(tryArray);
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonArray);
        cob.ifeq(end);

        cob.aload(currentSlot);
        cob.checkcast(CD_JsonArray);
        cob.invokeinterface(CD_JsonArray, "elements", MTD_List);
        cob.invokeinterface(CD_List, "iterator", MTD_Iterator);
        int arrIterSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(arrIterSlot);

        var arrLoopHead = cob.newLabel();
        var arrLoopEnd = cob.newLabel();
        cob.labelBinding(arrLoopHead);
        cob.aload(arrIterSlot);
        cob.invokeinterface(CD_Iterator, "hasNext", MTD_boolean);
        cob.ifeq(arrLoopEnd);
        cob.aload(arrIterSlot);
        cob.invokeinterface(CD_Iterator, "next", MTD_Object);
        cob.checkcast(CD_JsonValue);
        int arrChildSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(arrChildSlot);

        emitSegmentChain(cob, segments, segIdx + 1, arrChildSlot, rootSlot, resultsSlot);

        cob.goto_(arrLoopHead);
        cob.labelBinding(arrLoopEnd);

        cob.labelBinding(end);
    }

    /// RecursiveDescent: use runtime helper to collect matches, then continue chain.
    ///
    /// Cannot inline recursive descent by recursively calling emitSegmentChain with
    /// the same segIdx (causes StackOverflow at codegen time). Instead, delegate the
    /// DFS traversal to [RecursiveDescentHelper] at runtime and loop over the results.
    private static void emitRecursiveDescent(CodeBuilder cob, RecursiveDescent desc,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        final var target = desc.target();

        // If there are no more segments after this one, collect directly into results
        final boolean isLastSegment = (segIdx + 1 >= segments.size());

        // Allocate a temporary list for intermediate results
        int tempListSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.new_(CD_ArrayList);
        cob.dup();
        cob.invokespecial(CD_ArrayList, ConstantDescs.INIT_NAME, ConstantDescs.MTD_void);
        cob.astore(tempListSlot);

        switch (target) {
            case PropertyAccess prop -> {
                // RecursiveDescentHelper.findProperty(current, name, tempList)
                cob.aload(currentSlot);
                cob.ldc(prop.name());
                cob.aload(tempListSlot);
                cob.invokestatic(CD_RecursiveDescentHelper, "findProperty",
                    MTD_void_JsonValue_String_List);
            }
            case Wildcard _ -> {
                // RecursiveDescentHelper.findAll(current, tempList)
                cob.aload(currentSlot);
                cob.aload(tempListSlot);
                cob.invokestatic(CD_RecursiveDescentHelper, "findAll",
                    MTD_void_JsonValue_List);
            }
            default -> {
                // For other target types, fall back to emitting the target match
                // at the current level only (no deep recursion)
                emitTargetMatch(cob, target, segments, segIdx, currentSlot, rootSlot, resultsSlot);
                return;
            }
        }

        if (isLastSegment) {
            // Add all intermediate results directly to the final results
            cob.aload(resultsSlot);
            cob.aload(tempListSlot);
            cob.invokevirtual(CD_ArrayList, "addAll",
                MethodTypeDesc.of(ConstantDescs.CD_boolean, CD_Collection));
            cob.pop();
        } else {
            // Loop over intermediate results and continue the segment chain
            cob.aload(tempListSlot);
            cob.invokevirtual(CD_ArrayList, "iterator", MTD_Iterator);
            int iterSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(iterSlot);

            var loopHead = cob.newLabel();
            var loopEnd = cob.newLabel();
            cob.labelBinding(loopHead);
            cob.aload(iterSlot);
            cob.invokeinterface(CD_Iterator, "hasNext", MTD_boolean);
            cob.ifeq(loopEnd);
            cob.aload(iterSlot);
            cob.invokeinterface(CD_Iterator, "next", MTD_Object);
            cob.checkcast(CD_JsonValue);
            int matchSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(matchSlot);

            emitSegmentChain(cob, segments, segIdx + 1, matchSlot, rootSlot, resultsSlot);

            cob.goto_(loopHead);
            cob.labelBinding(loopEnd);
        }
    }

    /// Emits code to match a target segment (the segment inside RecursiveDescent)
    private static void emitTargetMatch(CodeBuilder cob, Segment target,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        switch (target) {
            case PropertyAccess prop -> {
                var skip = cob.newLabel();
                cob.aload(currentSlot);
                cob.instanceOf(CD_JsonObject);
                cob.ifeq(skip);

                cob.aload(currentSlot);
                cob.checkcast(CD_JsonObject);
                cob.invokeinterface(CD_JsonObject, "members", MTD_Map);
                cob.ldc(prop.name());
                cob.invokeinterface(CD_Map, "get", MTD_Object_Object);
                int valSlot = cob.allocateLocal(TypeKind.REFERENCE);
                cob.astore(valSlot);
                cob.aload(valSlot);
                cob.ifnull(skip);

                cob.aload(valSlot);
                cob.checkcast(CD_JsonValue);
                int matchSlot = cob.allocateLocal(TypeKind.REFERENCE);
                cob.astore(matchSlot);

                emitSegmentChain(cob, segments, segIdx + 1, matchSlot, rootSlot, resultsSlot);

                cob.labelBinding(skip);
            }
            case Wildcard _ -> {
                // Wildcard in recursive descent: match all children at this level
                emitWildcard(cob, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            }
            case ArrayIndex arr -> {
                emitArrayIndex(cob, arr, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            }
            case Filter filter -> {
                emitFilter(cob, filter, segments, segIdx, currentSlot, rootSlot, resultsSlot);
            }
            default -> {
                // Other segment types in recursive descent are uncommon.
                // For now, skip unsupported targets.
                JsonPathCodegen.LOG.warning(() -> "Unsupported recursive descent target: " + target.getClass().getSimpleName());
            }
        }
    }

    /// Filter: iterate array elements, test predicate, recurse matches
    private static void emitFilter(CodeBuilder cob, Filter filter,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        var end = cob.newLabel();

        // if (!(current instanceof JsonArray)) skip
        cob.aload(currentSlot);
        cob.instanceOf(CD_JsonArray);
        cob.ifeq(end);

        cob.aload(currentSlot);
        cob.checkcast(CD_JsonArray);
        cob.invokeinterface(CD_JsonArray, "elements", MTD_List);
        cob.invokeinterface(CD_List, "iterator", MTD_Iterator);
        int iterSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(iterSlot);

        var loopHead = cob.newLabel();
        var loopEnd = cob.newLabel();
        cob.labelBinding(loopHead);
        cob.aload(iterSlot);
        cob.invokeinterface(CD_Iterator, "hasNext", MTD_boolean);
        cob.ifeq(loopEnd);
        cob.aload(iterSlot);
        cob.invokeinterface(CD_Iterator, "next", MTD_Object);
        cob.checkcast(CD_JsonValue);
        int elemSlot = cob.allocateLocal(TypeKind.REFERENCE);
        cob.astore(elemSlot);

        // Emit filter predicate check
        var skipElem = cob.newLabel();
        EmitFilter.emitFilterExpression(cob, filter.expression(), elemSlot, rootSlot, skipElem);

        // Predicate passed: recurse with next segment
        emitSegmentChain(cob, segments, segIdx + 1, elemSlot, rootSlot, resultsSlot);

        cob.labelBinding(skipElem);
        cob.goto_(loopHead);
        cob.labelBinding(loopEnd);

        cob.labelBinding(end);
    }

    /// Union: iterate selectors, dispatch each
    private static void emitUnion(CodeBuilder cob, Union union,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        for (final var selector : union.selectors()) {
            switch (selector) {
                case PropertyAccess prop ->
                    emitPropertyAccess(cob, prop, segments, segIdx, currentSlot, rootSlot, resultsSlot);
                case ArrayIndex arr ->
                    emitArrayIndex(cob, arr, segments, segIdx, currentSlot, rootSlot, resultsSlot);
                default ->
                    JsonPathCodegen.LOG.warning(() -> "Unsupported union selector: " + selector.getClass().getSimpleName());
            }
        }
    }

    /// ScriptExpression: only @.length-1 is supported
    private static void emitScript(CodeBuilder cob, ScriptExpression script,
            List<Segment> segments, int segIdx, int currentSlot, int rootSlot, int resultsSlot) {

        if ("@.length-1".equals(script.script())) {
            // Emit equivalent of array[array.length - 1]
            var end = cob.newLabel();

            cob.aload(currentSlot);
            cob.instanceOf(CD_JsonArray);
            cob.ifeq(end);

            cob.aload(currentSlot);
            cob.checkcast(CD_JsonArray);
            cob.invokeinterface(CD_JsonArray, "elements", MTD_List);
            int listSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(listSlot);

            cob.aload(listSlot);
            cob.invokeinterface(CD_List, "size", MTD_int);
            int sizeSlot = cob.allocateLocal(TypeKind.INT);
            cob.istore(sizeSlot);

            // if (size == 0) skip
            cob.iload(sizeSlot);
            cob.ifeq(end);

            // list.get(size - 1)
            cob.aload(listSlot);
            cob.iload(sizeSlot);
            cob.ldc(1);
            cob.isub();
            cob.invokeinterface(CD_List, "get", MTD_Object_int);
            cob.checkcast(CD_JsonValue);
            int elemSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(elemSlot);

            emitSegmentChain(cob, segments, segIdx + 1, elemSlot, rootSlot, resultsSlot);

            cob.labelBinding(end);
        } else {
            JsonPathCodegen.LOG.warning(() -> "Unsupported script expression: " + script.script());
        }
    }
}
