package json.java21.jsonpath.codegen;

import java.lang.classfile.*;
import java.lang.constant.ClassDesc;
import java.lang.constant.ConstantDescs;
import java.lang.constant.MethodTypeDesc;

import json.java21.jsonpath.JsonPathAst.*;

import static json.java21.jsonpath.codegen.Descriptors.*;

/// Emits bytecode for JsonPath filter expressions.
///
/// Filter expressions are boolean predicates that gate whether an array
/// element enters the result pipeline. The generated bytecode evaluates
/// the predicate and jumps to `failLabel` if the predicate is false.
final class EmitFilter {

    private EmitFilter() {}

    /// Emits bytecode that evaluates a filter expression.
    /// If the expression evaluates to false, jumps to failLabel.
    /// If true, falls through to the next instruction.
    ///
    /// @param cob the code builder
    /// @param expr the filter expression AST node
    /// @param currentSlot local variable slot holding the current element (JsonValue)
    /// @param rootSlot local variable slot holding the root document
    /// @param failLabel label to jump to if the predicate fails
    static void emitFilterExpression(CodeBuilder cob, FilterExpression expr,
            int currentSlot, int rootSlot, Label failLabel) {

        switch (expr) {
            case ExistsFilter exists ->
                emitExistsFilter(cob, exists, currentSlot, failLabel);
            case ComparisonFilter comp ->
                emitComparisonFilter(cob, comp, currentSlot, rootSlot, failLabel);
            case LogicalFilter logical ->
                emitLogicalFilter(cob, logical, currentSlot, rootSlot, failLabel);
            case CurrentNode _ -> {
                // @ alone is always true; fall through
            }
            case PropertyPath path ->
                emitPropertyPathExists(cob, path, currentSlot, failLabel);
            case LiteralValue _ -> {
                // Literal in filter position is always true; fall through
            }
        }
    }

    /// ExistsFilter: check if @.property.path resolves to non-null
    private static void emitExistsFilter(CodeBuilder cob, ExistsFilter exists,
            int currentSlot, Label failLabel) {
        emitPropertyPathExists(cob, exists.path(), currentSlot, failLabel);
    }

    /// Resolve a PropertyPath against current and jump to failLabel if null
    private static void emitPropertyPathExists(CodeBuilder cob, PropertyPath path,
            int currentSlot, Label failLabel) {

        // Walk the property chain: current.prop1.prop2...
        int walkSlot = currentSlot;

        for (final var prop : path.properties()) {
            var propFail = failLabel; // if any step fails, the whole path fails

            // if (!(walk instanceof JsonObject)) fail
            cob.aload(walkSlot);
            cob.instanceOf(CD_JsonObject);
            cob.ifeq(propFail);

            cob.aload(walkSlot);
            cob.checkcast(CD_JsonObject);
            cob.invokeinterface(CD_JsonObject, "members", MTD_Map);
            cob.ldc(prop);
            cob.invokeinterface(CD_Map, "get", MTD_Object_Object);
            int nextSlot = cob.allocateLocal(TypeKind.REFERENCE);
            cob.astore(nextSlot);
            cob.aload(nextSlot);
            cob.ifnull(propFail);

            walkSlot = nextSlot;
        }
        // If we get here, the path resolved to a non-null value -> predicate true
    }

    /// ComparisonFilter: resolve left and right, compare, jump to failLabel if false
    private static void emitComparisonFilter(CodeBuilder cob, ComparisonFilter comp,
            int currentSlot, int rootSlot, Label failLabel) {

        // Resolve left operand
        int leftSlot = emitResolveOperand(cob, comp.left(), currentSlot);
        // Resolve right operand
        int rightSlot = emitResolveOperand(cob, comp.right(), currentSlot);

        // Compare: we need to handle the comparison based on the operator
        // For simplicity, delegate to a runtime helper method
        // We'll use a static method call to a helper that does the comparison

        // Push left, right, op ordinal onto stack and call helper
        cob.aload(leftSlot);
        cob.aload(rightSlot);
        cob.ldc(comp.op().ordinal());
        cob.invokestatic(CD_FilterHelper, "compare",
            MethodTypeDesc.of(ConstantDescs.CD_boolean, CD_Object, CD_Object, ConstantDescs.CD_int));
        cob.ifeq(failLabel);
    }

    /// LogicalFilter: AND, OR, NOT
    private static void emitLogicalFilter(CodeBuilder cob, LogicalFilter logical,
            int currentSlot, int rootSlot, Label failLabel) {

        switch (logical.op()) {
            case AND -> {
                // Both must be true: if left fails -> fail, if right fails -> fail
                emitFilterExpression(cob, logical.left(), currentSlot, rootSlot, failLabel);
                if (logical.right() != null) {
                    emitFilterExpression(cob, logical.right(), currentSlot, rootSlot, failLabel);
                }
            }
            case OR -> {
                // Either can be true: try left, if succeeds skip right
                var rightCheck = cob.newLabel();
                var pass = cob.newLabel();

                // Try left
                emitFilterExpression(cob, logical.left(), currentSlot, rootSlot, rightCheck);
                cob.goto_(pass); // left passed, skip right

                // Try right
                cob.labelBinding(rightCheck);
                if (logical.right() != null) {
                    emitFilterExpression(cob, logical.right(), currentSlot, rootSlot, failLabel);
                } else {
                    cob.goto_(failLabel);
                }

                cob.labelBinding(pass);
            }
            case NOT -> {
                // Invert: if child succeeds -> fail
                var childPassed = cob.newLabel();
                var afterNot = cob.newLabel();

                emitFilterExpression(cob, logical.left(), currentSlot, rootSlot, afterNot);
                // Child passed, but we're NOT-ing -> fail
                cob.goto_(failLabel);

                cob.labelBinding(afterNot);
                // Child failed, but we're NOT-ing -> pass (fall through)
            }
        }
    }

    /// Resolves a filter operand to a Java Object in a local variable slot.
    /// Uses [FilterHelper.resolveOperand] at runtime for property paths to
    /// avoid complex branching that causes bytecode verifier issues.
    /// Returns the slot number.
    private static int emitResolveOperand(CodeBuilder cob, FilterExpression expr, int currentSlot) {
        int slot = cob.allocateLocal(TypeKind.REFERENCE);

        switch (expr) {
            case PropertyPath path -> {
                // Delegate to runtime helper: FilterHelper.resolvePath(current, prop1, prop2, ...)
                // For simplicity, walk the path inline and extract at the end
                cob.aload(currentSlot);
                // Build a comma-separated property list and call runtime helper
                final var props = path.properties();
                // Push the number of properties
                cob.ldc(props.size());
                // Create a String array
                cob.anewarray(CD_String);
                for (int i = 0; i < props.size(); i++) {
                    cob.dup();
                    cob.ldc(i);
                    cob.ldc(props.get(i));
                    cob.aastore();
                }
                cob.invokestatic(CD_FilterHelper, "resolvePath",
                    MethodTypeDesc.of(CD_Object, CD_Object, CD_String.arrayType()));
                cob.astore(slot);
            }
            case LiteralValue lit -> {
                if (lit.value() == null) {
                    cob.aconst_null();
                } else if (lit.value() instanceof String s) {
                    cob.ldc(s);
                } else if (lit.value() instanceof Number n) {
                    cob.ldc(n.doubleValue());
                    cob.invokestatic(ClassDesc.of("java.lang.Double"), "valueOf",
                        MethodTypeDesc.of(ClassDesc.of("java.lang.Double"), ConstantDescs.CD_double));
                } else if (lit.value() instanceof Boolean b) {
                    cob.ldc(b ? 1 : 0);
                    cob.invokestatic(ClassDesc.of("java.lang.Boolean"), "valueOf",
                        MethodTypeDesc.of(ClassDesc.of("java.lang.Boolean"), ConstantDescs.CD_boolean));
                } else {
                    cob.aconst_null();
                }
                cob.astore(slot);
            }
            case CurrentNode _ -> {
                cob.aload(currentSlot);
                cob.invokestatic(CD_FilterHelper, "extractValue",
                    MethodTypeDesc.of(CD_Object, CD_Object));
                cob.astore(slot);
            }
            default -> {
                cob.aconst_null();
                cob.astore(slot);
            }
        }

        return slot;
    }

    /// ClassDesc for the runtime filter helper
    static final ClassDesc CD_FilterHelper = ClassDesc.of("json.java21.jsonpath.codegen.FilterHelper");
}
