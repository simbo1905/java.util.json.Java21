package json.java21.jsonpath.codegen;

import jdk.sandbox.java.util.json.*;
import json.java21.jsonpath.JsonPathAst.ComparisonOp;

/// Runtime helper methods called by generated bytecode for filter evaluation.
///
/// These methods are invoked via `invokestatic` from the generated classfiles.
/// They handle value extraction and comparison logic that would be too complex
/// to emit entirely as bytecode.
public final class FilterHelper {

    private FilterHelper() {}

    /// Extracts a Java Object from a JsonValue for comparison purposes.
    ///
    /// @param value a JsonValue (or null)
    /// @return the extracted value: String, Double, Boolean, or null
    public static Object extractValue(Object value) {
        return switch (value) {
            case JsonString s -> s.string();
            case JsonNumber n -> n.toDouble();
            case JsonBoolean b -> b.bool();
            case JsonNull _ -> null;
            case null -> null;
            default -> value; // pass through for non-JSON values
        };
    }

    /// Resolves a property path on a value, returning the extracted Java value.
    ///
    /// @param current the starting value (typically a JsonValue)
    /// @param properties the property names to walk
    /// @return the extracted Java value at the end of the path, or null if any step fails
    public static Object resolvePath(Object current, String... properties) {
        Object walk = current;
        for (final var prop : properties) {
            if (walk instanceof JsonObject obj) {
                walk = obj.members().get(prop);
                if (walk == null) return null;
            } else {
                return null;
            }
        }
        return extractValue(walk);
    }

    /// Compares two values using the given comparison operator ordinal.
    ///
    /// The opOrdinal maps to [ComparisonOp] values:
    /// 0=EQ, 1=NE, 2=LT, 3=LE, 4=GT, 5=GE
    ///
    /// @param left the left operand (may be null)
    /// @param right the right operand (may be null)
    /// @param opOrdinal the ordinal of the ComparisonOp enum
    /// @return true if the comparison holds
    public static boolean compare(Object left, Object right, int opOrdinal) {
        final var op = ComparisonOp.values()[opOrdinal];

        // Null handling
        if (left == null || right == null) {
            return switch (op) {
                case EQ -> left == right;
                case NE -> left != right;
                default -> false;
            };
        }

        // Number comparison
        if (left instanceof Number leftNum && right instanceof Number rightNum) {
            final var cmp = Double.compare(leftNum.doubleValue(), rightNum.doubleValue());
            return switch (op) {
                case EQ -> cmp == 0;
                case NE -> cmp != 0;
                case LT -> cmp < 0;
                case LE -> cmp <= 0;
                case GT -> cmp > 0;
                case GE -> cmp >= 0;
            };
        }

        // String comparison
        if (left instanceof String leftStr && right instanceof String rightStr) {
            final var cmp = leftStr.compareTo(rightStr);
            return switch (op) {
                case EQ -> cmp == 0;
                case NE -> cmp != 0;
                case LT -> cmp < 0;
                case LE -> cmp <= 0;
                case GT -> cmp > 0;
                case GE -> cmp >= 0;
            };
        }

        // Boolean comparison (EQ/NE only)
        if (left instanceof Boolean && right instanceof Boolean) {
            return switch (op) {
                case EQ -> left.equals(right);
                case NE -> !left.equals(right);
                default -> false;
            };
        }

        // Fallback: equals for EQ/NE, false otherwise
        return switch (op) {
            case EQ -> left.equals(right);
            case NE -> !left.equals(right);
            default -> false;
        };
    }
}
